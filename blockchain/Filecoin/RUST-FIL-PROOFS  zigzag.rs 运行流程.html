<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308292 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1242"/>

<div>
<span><div>filecoin-proofs\examples\zigzag.rs</div><div>使用的命令</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/mnt/d/go/src/github.com/filecoin-project/go-filecoin/proofs/rust-fil-proofs/target/release/examples/zigzag --challenges 1 --size 1 --sloth 0 --m 5 --expansion 8 --hasher pedersen --layers 10 --partitions 1 --groth</div></div><div>size-The data size in KB;</div><div>m-The size of m，Base degree of DRG;【drg_graph中的parents的最大值？】</div><div>sloth-The number of sloth iterations;</div><div>ex</div><div>pansion-Expansion degree;【zigzag_graph中的expansion_parent的数量】</div><div>challenges-How many challenges to execute;</div><div>layers-How many layers to use;</div><div>partitions-How many circuit partitions to use;【每个layer分成几个partition来挑战】</div><div>groth-Generate and verify a groth circuit proof.</div><div>circuit-Print the constraint system;默认false；</div><div>bench-synthesize and report inputs/constraints for a circuit；默认true</div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">1.读取命令行中的参数</span></font></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">2.generating fake data   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：121</span></font></div><div><br/></div><div>2.1通过随机数产生replica_id<span style="font-weight: bold;">（本测试中随机种子固定所以其实固定）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let rng = &amp;mut XorShiftRng::from_seed([0x3dbe6259, 0x8d313d76, 0x3237db17, 0xe5bc0654]);</div><div><br/></div><div>let replica_id: H::Domain = rng.gen();</div></div><div><br/></div><div>2.2<span style="font-weight: bold;">生成SetupParams，基本就是对我们命令行中参数的打包</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let sp = layered_drgporep::SetupParams {</div><div>    drg_porep_setup_params: drgporep::SetupParams {</div><div>        drg: drgporep::DrgParams {</div><div>            nodes,</div><div>            degree: m,</div><div>            expansion_degree,</div><div>            seed: new_seed(),</div><div>        },</div><div>        sloth_iter,</div><div>    },</div><div>    layer_challenges: layer_challenges.clone(),</div><div>};</div></div><div><br/></div><div>nodes=size/32；degree：Base degree of DRG，layer_challenges是一个对layers和challenges的打包</div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">3.setup   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：139</span></font></div><div><br/></div><div><span style="font-weight: bold;">3.1生成layered PublicParament pp</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let pp = ZigZagDrgPoRep::&lt;H&gt;::setup(&amp;sp).unwrap();</div></div><div>这里调用了storage-proofs\src\layered_drgporep.rs 460的setup方法</div><div><span style="font-weight: bold;">主要是生成了graph并和其他参数一起打包成L</span><span style="font-weight: bold;">ayeredPublicParament</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn setup(sp: &amp;Self::SetupParams) -&gt; Result&lt;Self::PublicParams&gt; {</div><div>    let dp_sp = DrgPoRep::setup(&amp;sp.drg_porep_setup_params)?;</div><div>    let pp = PublicParams {</div><div>        drg_porep_public_params: dp_sp,</div><div>        layer_challenges: sp.layer_challenges.clone(),</div><div>    };</div><div>    Ok(pp)</div><div>}</div></div><div><br/></div><div>storage-proofs\src\drgporep.rs：245</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn setup(sp: &amp;Self::SetupParams) -&gt; Result&lt;Self::PublicParams&gt; {</div><div>    let graph = G::new(</div><div>        sp.drg.nodes,</div><div>        sp.drg.degree,</div><div>        sp.drg.expansion_degree,</div><div>        sp.drg.seed,</div><div>    );</div><div><br/></div><div>    Ok(PublicParams::new(graph, sp.sloth_iter))</div><div>}</div></div><div>【注意layered_drg和drg的struct都叫PublicParams，注意区分】</div><div>3.2 生成groth参数【大小G级，时间分钟级】 rs：144  </div><div><br/></div><div>3.2.1 <span style="font-weight: bold;">利用pp和jubjubBls12构造一个circuit</span></div><div>circuit takes PublicInputs, PublicParams, and Proof from this CompoundProof's proof::ProofScheme (S) and uses them to initialize Circuit fields which will be used to construct public and private inputs during circuit synthesis.</div><div><br/></div><div>3.2.2 设置cache的parameter set identifier和路径</div><div>/tmp/filecoin-proof-parameters/v9-zigzag-proof-of-replication-be7c4c2ea6d78c75ea695628a7f394fc4f4298a1c670a3a2b4c98c5c45fae956</div><div><br/></div><div>3.2.3最终调用到storage-proofs\src\parameter_cache.rs rs:65来生成groth parameter<span style="font-weight: bold;">（这里使用了固定的时间种子，所以groth parameter应该固定）</span></div><div><br/></div><div>3.2.4 把groth parameter写进磁盘（groth_parameter_bytes: 1353794232，目前两次都是这个大小）</div><div><br/></div><div><span style="font-weight: bold;">3.3 生成data</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let mut data = file_backed_mmap_from_random_bytes(nodes);</div></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">4.replicate   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">:155</span></font></div><div><font style="font-size: 14pt;"><br/></font></div><div>4.1 调用<span style="font-weight: bold;">replicate</span>函数 storage-proofs\src\layered_drgporep.rs：607</div><div>得到<span style="font-weight: bold;">tau和aux</span>，tau：每一层的comm-r和comm-d，以及comm_r_star，aux：每层的tree-r</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let (tau, aux) = ZigZagDrgPoRep::&lt;H&gt;::replicate(&amp;pp, &amp;replica_id, &amp;mut data, None).unwrap();</div></div><div><br/></div><div>4.2 <span style="font-weight: bold;">首先会调用transform_and_replicate_layers（</span><span style="font-weight: bold;">storage-proofs\src\layered_drgporep.rs：320</span><span style="font-weight: bold;">），得到taus和taxs。</span>replicate就不用解释了，这里讲下transform，他的输入是这个layer的drg pp，返回的是下层layer的drg pp</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let (taus,auxs)=     </div><div>    Self::transform_and_replicate_layers(&amp;pp.drg_porep_public_params,pp.layer_challenges.layers(),replica_id,data,)?;</div></div><div>layeredDRG复制是逐层复制的，单层复制调用storage-proofs\src\drgporep.rs:421，然后push得到的tau和aux.tree_r，然后进行transform继续复制下一层</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(0..layers).fold((*drgpp).clone(), |current_drgpp, layer| {</div><div>    let previous_replica_tree = if !auxs.is_empty() {</div><div>        auxs.last().cloned()</div><div>    } else {</div><div>        None</div><div>    };</div><div><br/></div><div>    let (tau, aux) =</div><div><b>        DrgPoRep::replicate(&amp;current_drgpp, replica_id, data, previous_replica_tree).unwrap();</b></div><div><br/></div><div>    taus.push(tau);</div><div>    auxs.push(aux.tree_r);</div><div><br/></div><div>    Self::transform(&amp;current_drgpp, layer, layers)</div><div>});</div></div><div><br/></div><div>从这里我们可以看出</div><div><span style="font-weight: bold;">这里的输出taus：每一层的comm_r和comm_d，auxs:每一层的tree_r</span></div><div><br/></div><div>4.3单层replicate函数如下图所示storage-proofs\src\drgporep.rs:421</div><div><span style="font-weight: bold;">所以replicate的本质就是调用vde的encode，encode的方式是</span><span style="font-weight: bold;">sloth_encode，</span><span style="font-weight: bold;">同时encode会覆盖原始数据</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn replicate(</div><div>    pp: &amp;Self::PublicParams,</div><div>    replica_id: &amp;H::Domain,</div><div>    data: &amp;mut [u8],</div><div>    data_tree: Option&lt;MerkleTree&lt;H::Domain, H::Function&gt;&gt;,</div><div>) -&gt; Result&lt;(porep::Tau&lt;H::Domain&gt;, porep::ProverAux&lt;H&gt;)&gt; {</div><div>    let tree_d = match data_tree {</div><div>        Some(tree) =&gt; tree,</div><div>        None =&gt; pp.graph.merkle_tree(data)?,</div><div>    };</div><div><br/></div><div>    vde::encode(&amp;pp.graph, pp.sloth_iter, replica_id, data)?;</div><div><br/></div><div>    let comm_d = tree_d.root();</div><div>    let tree_r = pp.graph.merkle_tree(data)?;</div><div>    let comm_r = tree_r.root();</div><div>    Ok((</div><div>        porep::Tau::new(comm_d, comm_r),</div><div>        porep::ProverAux::new(tree_d, tree_r),</div><div>    ))</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">4.4此处的merkel tree最下面一层是元数据，上面的节点才是对应的哈希值</span><span style="font-weight: bold;">storage-proofs\src\hasher\pedersen.rs ：227</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn node(</div><div>    &amp;mut self,</div><div>    left: PedersenDomain,</div><div>    right: PedersenDomain,</div><div>    height: usize,</div><div>) -&gt; PedersenDomain {</div><div>    let lhs = BitVec::&lt;bitvec::LittleEndian, u64&gt;::from(&amp;(left.0).0[..]);</div><div>    let rhs = BitVec::&lt;bitvec::LittleEndian, u64&gt;::from(&amp;(right.0).0[..]);</div><div><br/></div><div>    let bits = lhs</div><div>        .iter()</div><div>        .take(Fr::NUM_BITS as usize)</div><div>        .chain(rhs.iter().take(Fr::NUM_BITS as usize));</div><div><br/></div><div>    pedersen_hash::&lt;Bls12, _&gt;(</div><div>        Personalization::MerkleTree(height),</div><div>        bits,</div><div>        &amp;pedersen::JJ_PARAMS,</div><div>    )</div><div>    .into_xy()</div><div>    .0</div><div>    .into()</div><div>}</div></div><div><br/></div><div><br/></div><div>tree_r和comm_r都是encode后的数据的merkle tree和他的root</div><div><br/></div><div><br/></div><div>4.5 回到layered_drgporep.rs的replicate</div><div>我们先通过transform_and_replicate_layers得到了taus和auxs</div><div>之后我们会将taus中的comm_r和replicate id组合后进行一次哈希形成<span style="font-weight: bold;">comm_r_star</span>=hash(replica_id|comm_r[0]|comm_r[1]|…comm_r[n])</div><div>，然后<span style="font-weight: bold;">和taus一起封装成tau</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let comm_rs: Vec&lt;_&gt; = taus.iter().map(|tau| tau.comm_r).collect();</div><div>let crs = comm_r_star::&lt;L::Hasher&gt;(replica_id, &amp;comm_rs)?;</div><div>let tau = Tau {</div><div>    layer_taus: taus,</div><div>    comm_r_star: crs,</div><div>    };</div><div>Ok((tau, auxs))</div></div><div><br/></div><div>4.6 得到了tau和aux，随后我们来<span style="font-weight: bold;">构造pub-inputs和priv-inputs</span></div><div>simplify是指保留原始数据的comm-d和最后一次复制的comm-r。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let pub_inputs = layered_drgporep::PublicInputs::&lt;H::Domain&gt; {</div><div>    replica_id,</div><div>    tau: Some(tau.simplify().into()),</div><div>    comm_r_star: tau.comm_r_star,</div><div>    k: Some(0),</div><div>};</div><div><br/></div><div>let priv_inputs = layered_drgporep::PrivateInputs {</div><div>    aux,</div><div>    tau: tau.layer_taus,</div><div>};</div></div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">5.prove   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：188</span></font></div><div>利用pp，pub-inputs，priv-inputs，生成proof</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let all_partition_proofs =ZigZagDrgPoRep::&lt;H&gt;::prove_all_partitions(&amp;pp, &amp;pub_inputs, &amp;priv_inputs, partitions).expect(&quot;failed to prove&quot;);</div></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">5.1</span>storage-proofs\src\layered_drgporep.rs:<span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">484   </span><span style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">prove_all_partition</span>，</span></div><div><span style="font-size: 10pt;">调用了prove layers</span><span style="font-size: 10pt;">这个得到每个layer的每个partition的proof构成的二位数组，然后进行封装，最终返回的是Proof结构体的矢量，</span><span style="font-size: 10pt; font-weight: bold;">Proof结构体包含每个partition通过drg prove（）计算出来的encoding proof结构体和tau{comm_d和comm_r}</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn prove_all_partitions&lt;'b&gt;(</div><div>    pub_params: &amp;'b Self::PublicParams,</div><div>    pub_inputs: &amp;'b Self::PublicInputs,</div><div>    priv_inputs: &amp;'b Self::PrivateInputs,</div><div>    partition_count: usize,</div><div>) -&gt; Result&lt;Vec&lt;Self::Proof&gt;&gt; {</div><div>    assert!(partition_count &gt; 0);</div><div><br/></div><div>    let proofs = Self::prove_layers(</div><div>        &amp;pub_params.drg_porep_public_params,</div><div>        pub_inputs,</div><div>        &amp;priv_inputs.tau,</div><div>        &amp;priv_inputs.aux,</div><div>        &amp;pub_params.layer_challenges,</div><div>        pub_params.layer_challenges.layers(),</div><div>        pub_params.layer_challenges.layers(),</div><div>        partition_count,</div><div>    )?;</div><div><br/></div><div>    let mut proof_columns = vec![Vec::new(); partition_count];</div><div><br/></div><div>    for partition_proofs in proofs.into_iter() {</div><div>        for (j, proof) in partition_proofs.into_iter().enumerate() {</div><div>            proof_columns[j].push(proof);</div><div>        }</div><div>    }</div><div><br/></div><div>    let proofs = proof_columns</div><div>        .into_iter()</div><div>        .map(|p| Proof::new(p, priv_inputs.tau.clone()))</div><div>        .collect();</div><div><br/></div><div>    Ok(proofs)</div><div>}</div></div><div>返回值是每个partition的Proof结构体的collect</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Proof {</div><div>    encoding_proofs,</div><div>    tau,</div><div>}</div></div><div><br/></div><div>5.2<span style="font-weight: bold;">prove_layers</span>，storage-proofs\src\layered_drgporep.rs:244   我们可以简单理解为对每个layer的每个partition进行了一次prove并把结果放到二维数组中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn prove_layers&lt;'a&gt;(</div><div>    pp: &amp;drgporep::PublicParams&lt;Self::Hasher, Self::Graph&gt;,</div><div>    pub_inputs: &amp;PublicInputs&lt;&lt;Self::Hasher as Hasher&gt;::Domain&gt;,</div><div>    tau: &amp;[PorepTau&lt;Self::Hasher&gt;],</div><div>    aux: &amp;'a [Tree&lt;Self::Hasher&gt;],</div><div>    layer_challenges: &amp;LayerChallenges,</div><div>    layers: usize,</div><div>    total_layers: usize,</div><div>    partition_count: usize,</div><div>) -&gt; Result&lt;Vec&lt;Vec&lt;EncodingProof&lt;Self::Hasher&gt;&gt;&gt;&gt; {</div><div>    assert!(layers &gt; 0);</div><div><br/></div><div>    let mut new_pp = None;</div><div><br/></div><div>    (0..layers)</div><div>        .map(|layer| {</div><div>            let pp = match new_pp {</div><div>                Some(ref new_pp) =&gt; new_pp,</div><div>                None =&gt; pp,</div><div>            };</div><div>            let inner_layers = layers - layer;</div><div><br/></div><div>            let new_priv_inputs = drgporep::PrivateInputs {</div><div>                aux: &amp;porep::ProverAux {</div><div>                    tree_d: aux[layer].clone(),</div><div>                    tree_r: aux[layer + 1].clone(),</div><div>                },</div><div>            };</div><div>            let layer_diff = total_layers - inner_layers;</div><div><br/></div><div>            let partition_proofs: Vec&lt;_&gt; = (0..partition_count)</div><div>                .into_par_iter()</div><div>                .map(|k| {</div><div>                    let drgporep_pub_inputs = drgporep::PublicInputs {</div><div>                        replica_id: pub_inputs.replica_id,</div><div>                        challenges: pub_inputs.challenges(</div><div>                            layer_challenges,</div><div>                            pp.graph.size(),</div><div>                            layer_diff as u8,</div><div>                            Some(k),</div><div>                    ),</div><div>                    tau: Some(tau[layer]),</div><div>                };</div><div><b>                    DrgPoRep::prove(pp, &amp;drgporep_pub_inputs, &amp;new_priv_inputs)</b></div><div>                })</div><div>                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;</div><div><br/></div><div>            new_pp = Some(Self::transform(pp, layer_diff, total_layers));</div><div><br/></div><div>            Ok(partition_proofs)</div><div>        })</div><div>        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()</div><div>}</div></div><div><span style="font-weight: bold;">返回值是drgporep::Proof结构体的二维数组（在layer层我们叫他</span><span style="font-weight: bold;">EncodingProof</span><span style="font-weight: bold;">），具体请看下面drg的prove</span></div><div><font style="font-size: 10pt;"><br/></font></div><div>这里再讲一下这里的drgporep_pub_inputs，里面的replica_id和tau都是从上层搬来的不用细讲，这里值得我们关注的是这里的challenge,chanllenge最终会调用如下函数storage-proofs\src\challenge_derivation.rs ：9，这个函数主要是生成我们进行challenge的node的编号。<span style="font-weight: bold;">输入中，leaves就是我们的节点数，即data/32，k则是当前的partition的编号。commitment则是我们之前的comm_star。输出则是n个数字构成的数组。n是我们在命令行中输入的challenges，即挑战次数。</span></div><div><br/></div><div>总之就是将replicaid，commitment，layer，n，k按小字节序写出来再hash，再对节点数取模，<span style="font-weight: bold;">目前不允许挑战第一个和最后一个节点。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pub fn derive_challenges&lt;D: Domain&gt;(</div><div><span>    </span>challenges: &amp;LayerChallenges,</div><div><span>    </span>layer: u8,</div><div><span>    </span>leaves: usize,</div><div><span>    </span>replica_id: &amp;D,</div><div><span>    </span>commitment: &amp;D,</div><div><span>    </span>k: u8,</div><div>) -&gt; Vec&lt;usize&gt; {</div><div><span>    </span>let n = challenges.challenges_for_layer(layer as usize);</div><div><span>    </span>(0..n)</div><div><span>    </span><span>    </span>.map(|i| {</div><div><span>    </span><span>    </span><span>    </span>let mut bytes = replica_id.into_bytes();</div><div>            let j = ((n * k as usize) + i) as u32;</div><div>            bytes.extend(commitment.into_bytes());</div><div>            bytes.push(layer);</div><div>            bytes.write_u32::&lt;LittleEndian&gt;(j).unwrap();</div><div><br/></div><div>            let hash = blake2s(bytes.as_slice());</div><div>            let big_challenge = BigUint::from_bytes_le(hash.as_slice());</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>            let big_mod_challenge = big_challenge % (leaves - 2);</div><div>            big_mod_challenge.to_usize().unwrap() + 1</div><div><span>    </span><span>    </span>})</div><div><span>    </span><span>    </span>.collect()</div><div>}</div></div><div><br/></div><div>5.3.我们现在来看storage-proofs\src\drgporep.rs:256的prove，总结一下，包含三部分。</div><div>  </div><div>1.replica_nodes=r.data+r.proof</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>replica_nodes.push(DataProof {</div><div>   proof: MerkleProof::new_from_proof(&amp;tree_r.gen_proof(challenge)),</div><div>   data,</div><div>});</div></div><div>2.replica_parents=该node所有parents的（r.data+r.proof）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let parents = pub_params.graph.parents(challenge);</div><div>let mut replica_parentsi = Vec::with_capacity(parents.len());</div><div>for p in &amp;parents {</div><div>   replica_parentsi.push((*p, {</div><div>      let proof = tree_r.gen_proof(*p);</div><div>      DataProof {</div><div>         proof: MerkleProof::new_from_proof(&amp;proof),</div><div>         data: domain_replica[*p],</div><div>      }</div><div>   }));</div><div>}</div><div>replica_parents.push(replica_parentsi);</div></div><div>3.data_nodes=data<span style="font-weight: bold;">（decode的r.data）</span>+d.proof</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let node_proof = tree_d.gen_proof(challenge);</div><div><br/></div><div>{</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>let extracted = decode_domain_block::&lt;H&gt;(</div><div>   pub_params.graph.degree(),</div><div>   pub_params.sloth_iter,</div><div>   &amp;pub_inputs.replica_id,</div><div>   domain_replica,</div><div>   challenge,</div><div>   parents,</div><div>)?</div><div>.into_bytes();</div><div>data_nodes.push(DataProof {</div><div>   data: H::Domain::try_from_bytes(&amp;extracted)?,</div><div>   proof: MerkleProof::new_from_proof(&amp;node_proof),</div><div>   });</div><div> }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let proof = Proof::new(replica_nodes, replica_parents, data_nodes);</div><div>Ok(proof)</div></div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold;">prove（）返回的结构体构造如下</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Proof {</div><div>   data_root: *nodes[0].proof.root(),</div><div>   replica_root: *replica_nodes[0].proof.root(),</div><div>   replica_nodes,</div><div>   replica_parents,</div><div>   nodes,</div><div>}</div></div><div><br/></div><div>new_from_proof<span style="font-size: 10pt;">则是应用了merkle tree自带的结构里面的proof</span></div><div>D:\RUST\CARGO_HOME\git\checkouts\merkle_light-16b81cab1b05c5b8\63a609d\merkle\src\merkle.rs：97</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pub fn gen_proof(&amp;self, i: usize) -&gt; Proof&lt;T&gt; {</div><div>   assert!(i &lt; self.leafs); // i in [0 .. self.leafs)</div><div><br/></div><div>   let mut lemma: Vec&lt;T&gt; = Vec::with_capacity(self.height + 1); // path + root</div><div>   let mut path: Vec&lt;bool&gt; = Vec::with_capacity(self.height - 1); // path - 1</div><div><br/></div><div>   let mut base = 0;</div><div>   let mut j = i;</div><div><br/></div><div>   // level 1 width</div><div>   let mut width = self.leafs;</div><div>   if width &amp; 1 == 1 {</div><div>      width += 1;</div><div>   }</div><div><br/></div><div>   lemma.push(self.data[j].clone());</div><div>   while base + 1 &lt; self.len() {</div><div>      lemma.push(if j &amp; 1 == 0 {</div><div>         // j is left</div><div>         self.data[base + j + 1].clone()</div><div>      } else {</div><div>         // j is right</div><div>         self.data[base + j - 1].clone()</div><div>      });</div><div>      path.push(j &amp; 1 == 0);</div><div><br/></div><div>      base += width;</div><div>      width &gt;&gt;= 1;</div><div>      if width &amp; 1 == 1 {</div><div>         width += 1;</div><div>      }</div><div>      j &gt;&gt;= 1;</div><div>   }</div><div><br/></div><div>   // root is final</div><div>   lemma.push(self.root());</div><div>   Proof::new(lemma, path)</div><div>}</div><div><br/></div><div><br/></div></div><div>这个还是用图来说明好了</div><div><img src="RUST-FIL-PROOFS  zigzag.rs 运行流程_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>比如我们要产生2的proof，则会返回2，3，01，4567，01234567的哈希值，同时会返回从该节点到根节点的路径。</div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">6.verify </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：216</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">let verified =ZigZagDrgPoRep::&lt;H&gt;::verify_all_partitions(&amp;pp, &amp;pub_inputs, &amp;all_partition_proofs).expect(&quot;failed during verification&quot;);</font></div></div><div>verify过程如下storage-proofs\src\layered_drgporep.rs：519</div><div>对每个layer的partition进行prove，并把每层的tree_r拿出来计算comm_star</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn verify_all_partitions(</div><div>   pub_params: &amp;Self::PublicParams,</div><div>   pub_inputs: &amp;Self::PublicInputs,</div><div>   partition_proofs: &amp;[Self::Proof],</div><div>) -&gt; Result&lt;bool&gt; {</div><div>   for (k, proof) in partition_proofs.iter().enumerate() {</div><div>      if proof.encoding_proofs.len() != pub_params.layer_challenges.layers() {</div><div>         return Ok(false);</div><div>      }</div><div><br/></div><div>      let total_layers = pub_params.layer_challenges.layers();</div><div>      let mut pp = pub_params.drg_porep_public_params.clone();</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>      let mut comm_rs = Vec::new();</div><div><br/></div><div>      for (layer, proof_layer) in proof.encoding_proofs.iter().enumerate() {</div><div>         comm_rs.push(proof.tau[layer].comm_r);</div><div><br/></div><div>         let new_pub_inputs = drgporep::PublicInputs {</div><div>            replica_id: pub_inputs.replica_id,</div><div>            challenges: pub_inputs.challenges(</div><div>               &amp;pub_params.layer_challenges,</div><div>               pub_params.drg_porep_public_params.graph.size(),</div><div>               layer as u8,</div><div>               Some(k),</div><div>            ),</div><div>            tau: Some(proof.tau[layer]),</div><div>         };</div><div><br/></div><div>         let ep = &amp;proof_layer;</div><div>         let res = DrgPoRep::verify(</div><div>            &amp;pp,</div><div>            &amp;new_pub_inputs,</div><div>            &amp;drgporep::Proof {</div><div>               data_root: ep.data_root,</div><div>               replica_root: ep.replica_root,</div><div>               replica_nodes: ep.replica_nodes.clone(),</div><div>               replica_parents: ep.replica_parents.clone(),</div><div>               // TODO: investigate if clone can be avoided by using a reference </div><div>               // in drgporep::DataProof</div><div>               nodes: ep.nodes.clone(),</div><div>            },</div><div>         )?;</div><div><br/></div><div>         pp = Self::transform(&amp;pp, layer, total_layers);</div><div><br/></div><div>         if !res {</div><div>            return Ok(false);</div><div>         }</div><div>      }</div><div>      let crs = comm_r_star::&lt;L::Hasher&gt;(&amp;pub_inputs.replica_id, &amp;comm_rs)?;</div><div><br/></div><div>      if crs != pub_inputs.comm_r_star {</div><div>         return Ok(false);</div><div>      }</div><div>   }</div><div>   Ok(true)</div><div>}</div></div><div><br/></div><div><br/></div><div>其中的drg_prove结构如下：storage-proofs\src\drgporep.rs：328</div><div><br/></div><div>这里代码的可读性很好，verify总共分为三步。1.proof_meta  2.replica_nodes和replica_parents的verify（merkel tree的verify方法）3.对replica_nodes[i].data进行decode并与nodes[i].data进行比较</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>{</div><div>    // This was verify_proof_meta.</div><div>    if pub_inputs.challenges[i] &gt;= pub_params.graph.size() {</div><div>        return Ok(false);</div><div>    }</div><div><br/></div><div>    if !(proof.nodes[i].proves_challenge(pub_inputs.challenges[i])) {</div><div>        return Ok(false);</div><div>    }</div><div><br/></div><div>    if !(proof.replica_nodes[i].proves_challenge(pub_inputs.challenges[i])) {</div><div>        return Ok(false);</div><div>    }</div><div><br/></div><div>    let expected_parents = pub_params.graph.parents(pub_inputs.challenges[i]);</div><div>    if proof.replica_parents[i].len() != expected_parents.len() {</div><div>        println!(</div><div>            &quot;proof parents were not the same length as in public parameters: {} != {}&quot;,</div><div>            proof.replica_parents[i].len(),</div><div>            expected_parents.len()</div><div>        );</div><div>        return Ok(false);</div><div>    }</div><div><br/></div><div>    let parents_as_expected = proof.replica_parents[i]</div><div>        .iter()</div><div>        .zip(&amp;expected_parents)</div><div>        .all(|(actual, expected)| actual.0 == *expected);</div><div><br/></div><div>    if !parents_as_expected {</div><div>        println!(&quot;proof parents were not those provided in public parameters&quot;);</div><div>    return Ok(false);</div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let challenge = pub_inputs.challenges[i] % pub_params.graph.size();</div><div>assert_ne!(challenge, 0, &quot;cannot prove the first node&quot;);</div><div><br/></div><div>if !proof.replica_nodes[i].proof.validate(challenge) {</div><div>    println!(&quot;invalid replica node&quot;);</div><div>    return Ok(false);</div><div>}</div><div><br/></div><div>for (parent_node, p) in &amp;proof.replica_parents[i] {</div><div>    if !p.proof.validate(*parent_node) {</div><div>        println!(&quot;invalid replica parent: {:?}&quot;, p);</div><div>        return Ok(false);</div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let prover_bytes = &amp;pub_inputs.replica_id.into_bytes();</div><div><br/></div><div>let key_input =</div><div>    proof.replica_parents[i]</div><div>        .iter()</div><div>        .fold(prover_bytes.clone(), |mut acc, (_, p)| {</div><div>            acc.extend(&amp;p.data.into_bytes());</div><div>            acc</div><div>        });</div><div><br/></div><div>let key = H::kdf(key_input.as_slice(), pub_params.graph.degree());</div><div>let unsealed =</div><div>    H::sloth_decode(&amp;key, &amp;proof.replica_nodes[i].data, pub_params.sloth_iter);</div><div><br/></div><div>if unsealed != proof.nodes[i].data {</div><div>    return Ok(false);</div><div>}</div><div><br/></div><div>if !proof.nodes[i].proof.validate_data(&amp;unsealed.into_bytes()) {</div><div>    println!(&quot;invalid data for merkle path {:?}&quot;, unsealed);</div><div>    return Ok(false);</div><div>}</div></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">7.</span><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">groth prove    </span></span><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span><span style="font-size: 14pt; font-weight: bold;">：268</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let engine_params = JubjubBls12::new();</div><div><br/></div><div>let compound_public_params = compound_proof::PublicParams {</div><div>    vanilla_params: pp.clone(),</div><div>    engine_params: &amp;engine_params,</div><div>    partitions: Some(partitions),</div><div>};</div><div><br/></div><div>let result =</div><div>    ZigZagCompound::prove(&amp;compound_public_params, &amp;pub_inputs, &amp;priv_inputs, None).unwrap();</div></div><div><span style="font-weight: bold;">storage-proofs\src\compound_proof.rs:70的fn prove</span></div><div>1.参数配置</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let partitions = Self::partition_count(pub_params);</div><div>let partition_count = Self::partition_count(pub_params);</div><div><br/></div><div>let vanilla_proofs =</div><div>    S::prove_all_partitions(&amp;pub_params.vanilla_params, &amp;pub_in, priv_in, partitions)?;</div><div><br/></div><div>let sanity_check =</div><div>    S::verify_all_partitions(&amp;pub_params.vanilla_params, &amp;pub_in, &amp;vanilla_proofs)?;</div><div>assert!(sanity_check, &quot;sanity check failed&quot;);</div><div><br/></div><div>assert!(partition_count &gt; 0);</div><div><br/></div><div>let actual_groth_params = match groth_params {</div><div>    None =&gt; {</div><div>        let circuit = Self::circuit(</div><div>            &amp;pub_in,</div><div>            C::ComponentPrivateInputs::default(),</div><div>            // Use first vanilla proof to get circuit exemplar for parameter generation.</div><div>            &amp;vanilla_proofs[0],</div><div>            &amp;pub_params.vanilla_params,</div><div>            &amp;pub_params.engine_params,</div><div>        );</div><div>        Self::get_groth_params(circuit, &amp;pub_params.vanilla_params)?</div><div>    }</div><div>    Some(gp) =&gt; gp,</div><div>};</div></div><div>2.调用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let groth_proofs: Result&lt;Vec&lt;_&gt;&gt; = vanilla_proofs</div><div>    .par_iter()</div><div>    .map(|vanilla_proof| {</div><div>        <b>Self::circuit_proof</b>(</div><div>            pub_in,</div><div>            &amp;vanilla_proof,</div><div>            &amp;pub_params.vanilla_params,</div><div>            &amp;pub_params.engine_params,</div><div>            &amp;actual_groth_params,</div><div>        )</div><div>    })</div><div>    .collect();</div><div><br/></div><div>Ok(MultiProof::new(groth_proofs?, actual_groth_params.vk))</div></div><div>3.返回值</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pub struct MultiProof&lt;E: Engine&gt; {</div><div>    pub circuit_proofs: Vec&lt;groth16::Proof&lt;E&gt;&gt;,</div><div>    pub verifying_key: groth16::VerifyingKey&lt;E&gt;,</div><div>}</div></div><div><span style="font-weight: bold;">storage-proofs\src\compound_proof.rs：150</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn circuit_proof&lt;'b&gt;(</div><div>    pub_in: &amp;S::PublicInputs,</div><div>    vanilla_proof: &amp;S::Proof,</div><div>    pub_params: &amp;'b S::PublicParams,</div><div>    params: &amp;'a E::Params,</div><div>    groth_params: &amp;groth16::Parameters&lt;E&gt;,</div><div>) -&gt; Result&lt;groth16::Proof&lt;E&gt;&gt; {</div><div>    let rng = &amp;mut OsRng::new().unwrap();</div><div><br/></div><div>    // We need to make the circuit repeatedly because we can't clone it.</div><div>    // Fortunately, doing so is cheap.</div><div><br/></div><div>    let make_circuit = || {</div><div>        Self::circuit(</div><div>            &amp;pub_in,</div><div>            C::ComponentPrivateInputs::default(),</div><div>            &amp;vanilla_proof,</div><div>            &amp;pub_params,</div><div>            &amp;params,</div><div>        )</div><div>    };</div><div><br/></div><div><b>    let groth_proof = groth16::create_random_proof(make_circuit(), groth_params, rng)?;</b></div><div><br/></div><div>    let mut proof_vec = vec![];</div><div>    groth_proof.write(&amp;mut proof_vec)?;</div><div>    let gp = groth16::Proof::&lt;E&gt;::read(&amp;proof_vec[..])?;</div><div><br/></div><div>    Ok(gp)</div><div>}</div></div><div><br/></div></span>
</div></body></html> 