<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308292 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1242"/>

<div>
<span><div>filecoin-proofs\examples\zigzag.rs</div><div>使用的命令</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/mnt/d/go/src/github.com/filecoin-project/go-filecoin/proofs/rust-fil-proofs/target/release/examples/zigzag --challenges 1 --size 1 --sloth 0 --m 5 --expansion 8 --hasher pedersen --layers 10 --partitions 1 --groth</div></div><div>size-The data size in KB;</div><div>m-The size of m，Base degree of DRG;【drg_graph中的parents的最大值？】</div><div>sloth-The number of sloth iterations;</div><div>ex</div><div>pansion-Expansion degree;【zigzag_graph中的expansion_parent的数量】</div><div>challenges-How many challenges to execute;</div><div>layers-How many layers to use;</div><div>partitions-How many circuit partitions to use;【每个layer分成几个partition来挑战】</div><div>groth-Generate and verify a groth circuit proof.</div><div>circuit-Print the constraint system;默认false；</div><div>bench-synthesize and report inputs/constraints for a circuit；默认true</div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">1.读取命令行中的参数</span></font></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">2.生成</span></font><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">SetupParams</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：193</span></font></div><div><br/></div><div>2.1计算出node数并通过随机数产生replica_id<span style="font-weight: bold;">（本测试中随机种子固定所以其实固定）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let nodes = data_size / 32;</div><div>let rng = &amp;mut XorShiftRng::from_seed([0x3dbe6259, 0x8d313d76, 0x3237db17, 0xe5bc0654]);</div><div>let replica_id: H::Domain = rng.gen();</div></div><div><br/></div><div>2.2<span style="font-weight: bold;">生成SetupParams，基本就是对我们命令行中参数的打包</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let sp = layered_drgporep::SetupParams {</div><div>    drg_porep_setup_params: drgporep::SetupParams {</div><div>        drg: drgporep::DrgParams {</div><div>            nodes,                </div><div>            degree: m,            //Base degree of DRG    </div><div>            expansion_degree,</div><div>            seed: new_seed(),</div><div>        },</div><div>        sloth_iter,</div><div>    },</div><div>    layer_challenges: layer_challenges.clone(),      //对layers和challenges的打包  </div><div>};</div></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">3.setup   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：208</span></font></div><div><br/></div><div><span style="font-weight: bold;">3.1生成layered PublicParament pp</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let pp = ZigZagDrgPoRep::&lt;H&gt;::setup(&amp;sp).unwrap();</div></div><div>这里调用了storage-proofs\src\layered_drgporep.rs 460的setup方法</div><div><span style="font-weight: bold;">主要是生成了graph并和其他参数一起打包成L</span><span style="font-weight: bold;">ayeredPublicParament</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn setup(sp: &amp;Self::SetupParams) -&gt; Result&lt;Self::PublicParams&gt; {</div><div>    let dp_sp = DrgPoRep::setup(&amp;sp.drg_porep_setup_params)?;</div><div>    let pp = PublicParams {</div><div>        drg_porep_public_params: dp_sp,</div><div>        layer_challenges: sp.layer_challenges.clone(),</div><div>    };</div><div>    Ok(pp)</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">3.2 生成验证次数samples和data</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let samples: u32 = 5;    //这个为验证的次数</div><div>let mut data = file_backed_mmap_from_zeroes(nodes, use_tmp);</div></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">4.replicate   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">:226</span></font></div><div><font style="font-size: 14pt;"><br/></font></div><div>4.1 调用<span style="font-weight: bold;">replicate</span>函数 storage-proofs\src\layered_drgporep.rs：607</div><div>得到<span style="font-weight: bold;">tau和aux</span>，tau：每一层的comm-r和comm-d，以及comm_r_star，aux：每层的tree-r</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let (tau, aux) = ZigZagDrgPoRep::&lt;H&gt;::replicate(&amp;pp, &amp;replica_id, &amp;mut data, None).unwrap();</div></div><div><br/></div><div>4.2 <span style="font-weight: bold;">首先会调用transform_and_replicate_layers（</span><span style="font-weight: bold;">storage-proofs\src\layered_drgporep.rs：320</span><span style="font-weight: bold;">），得到taus和taxs。</span>replicate就不用解释了，这里讲下transform，他的输入是这个layer的drg pp，返回的是下层layer的drg pp</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let (taus,auxs)=     </div><div>    Self::transform_and_replicate_layers(&amp;pp.drg_porep_public_params,pp.layer_challenges.layers(),replica_id,data,)?;</div></div><div>layeredDRG复制是逐层复制的，单层复制调用storage-proofs\src\drgporep.rs:421，然后push得到的tau和aux.tree_r，然后进行transform继续复制下一层</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(0..layers).fold((*drgpp).clone(), |current_drgpp, layer| {</div><div>    let previous_replica_tree = if !auxs.is_empty() {</div><div>        auxs.last().cloned()</div><div>    } else {</div><div>        None</div><div>    };</div><div><br/></div><div>    let (tau, aux) =</div><div><b>        DrgPoRep::replicate(&amp;current_drgpp, replica_id, data, previous_replica_tree).unwrap();</b></div><div><br/></div><div>    taus.push(tau);</div><div>    auxs.push(aux.tree_r);</div><div><br/></div><div>    Self::transform(&amp;current_drgpp, layer, layers)</div><div>});</div></div><div><br/></div><div>从这里我们可以看出</div><div><span style="font-weight: bold;">这里的输出taus：每一层的comm_r和comm_d，auxs:每一层的tree_r</span></div><div><br/></div><div>4.3单层replicate函数如下图所示storage-proofs\src\drgporep.rs:421</div><div><span style="font-weight: bold;">所以replicate的本质就是调用vde的encode，encode的方式是</span><span style="font-weight: bold;">sloth_encode，</span><span style="font-weight: bold;">同时encode会覆盖原始数据</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn replicate(</div><div>    pp: &amp;Self::PublicParams,</div><div>    replica_id: &amp;H::Domain,</div><div>    data: &amp;mut [u8],</div><div>    data_tree: Option&lt;MerkleTree&lt;H::Domain, H::Function&gt;&gt;,</div><div>) -&gt; Result&lt;(porep::Tau&lt;H::Domain&gt;, porep::ProverAux&lt;H&gt;)&gt; {</div><div>    let tree_d = match data_tree {</div><div>        Some(tree) =&gt; tree,</div><div>        None =&gt; pp.graph.merkle_tree(data)?,</div><div>    };</div><div><br/></div><div><b>    vde::encode(&amp;pp.graph, pp.sloth_iter, replica_id, data)?;</b></div><div><br/></div><div>    let comm_d = tree_d.root();</div><div>    let tree_r = pp.graph.merkle_tree(data)?;</div><div>    let comm_r = tree_r.root();</div><div>    Ok((</div><div>        porep::Tau::new(comm_d, comm_r),</div><div>        porep::ProverAux::new(tree_d, tree_r),</div><div>    ))</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">4.4此处的merkel tree最下面一层是元数据，上面的节点才是对应的哈希值</span><span style="font-weight: bold;">storage-proofs\src\hasher\pedersen.rs ：227</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn node(</div><div>    &amp;mut self,</div><div>    left: PedersenDomain,</div><div>    right: PedersenDomain,</div><div>    height: usize,</div><div>) -&gt; PedersenDomain {</div><div>    let lhs = BitVec::&lt;bitvec::LittleEndian, u64&gt;::from(&amp;(left.0).0[..]);</div><div>    let rhs = BitVec::&lt;bitvec::LittleEndian, u64&gt;::from(&amp;(right.0).0[..]);</div><div><br/></div><div>    let bits = lhs</div><div>        .iter()</div><div>        .take(Fr::NUM_BITS as usize)</div><div>        .chain(rhs.iter().take(Fr::NUM_BITS as usize));</div><div><br/></div><div>    pedersen_hash::&lt;Bls12, _&gt;(</div><div>        Personalization::MerkleTree(height),</div><div>        bits,</div><div>        &amp;pedersen::JJ_PARAMS,</div><div>    )</div><div>    .into_xy()</div><div>    .0</div><div>    .into()</div><div>}</div></div><div><br/></div><div><br/></div><div>tree_r和comm_r都是encode后的数据的merkle tree和他的root</div><div><br/></div><div><br/></div><div>4.5 回到layered_drgporep.rs的replicate</div><div>我们先通过transform_and_replicate_layers得到了taus和auxs</div><div>之后我们会将taus中的comm_r和replicate id组合后进行一次哈希形成<span style="font-weight: bold;">comm_r_star</span>=hash(replica_id|comm_r[0]|comm_r[1]|…comm_r[n])</div><div>，然后<span style="font-weight: bold;">和taus一起封装成tau</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let comm_rs: Vec&lt;_&gt; = taus.iter().map(|tau| tau.comm_r).collect();</div><div>let crs = comm_r_star::&lt;L::Hasher&gt;(replica_id, &amp;comm_rs)?;</div><div>let tau = Tau {</div><div>    layer_taus: taus,</div><div>    comm_r_star: crs,</div><div>    };</div><div>Ok((tau, auxs))</div></div><div><br/></div><div>4.6 得到了tau和aux，随后我们来<span style="font-weight: bold;">构造pub-inputs和priv-inputs</span></div><div>simplify是指保留原始数据的comm-d和最后一次复制的comm-r。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let pub_inputs = layered_drgporep::PublicInputs::&lt;H::Domain&gt; {</div><div>    replica_id,</div><div>    tau: Some(tau.simplify().into()),</div><div>    comm_r_star: tau.comm_r_star,</div><div>    k: Some(0),</div><div>};</div><div><br/></div><div>let priv_inputs = layered_drgporep::PrivateInputs {</div><div>    aux,</div><div>    tau: tau.layer_taus,</div><div>};</div></div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">5.prove   </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：271</span></font></div><div>利用pp，pub-inputs，priv-inputs，生成proof</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let all_partition_proofs =ZigZagDrgPoRep::&lt;H&gt;::prove_all_partitions(&amp;pp, &amp;pub_inputs, &amp;priv_inputs, partitions).expect(&quot;failed to prove&quot;);</div></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">5.1</span>storage-proofs\src\layered_drgporep.rs:<span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">484   </span><span style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">prove_all_partition</span>，</span></div><div><span style="font-size: 10pt;">调用了prove layers</span><span style="font-size: 10pt;">这个得到每个layer的每个partition的proof构成的二位数组，然后进行封装，最终返回的是Proof结构体的矢量，</span><span style="font-size: 10pt; font-weight: bold;">Proof结构体包含每个partition通过drg prove（）计算出来的encoding proof结构体和tau{comm_d和comm_r}</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn prove_all_partitions&lt;'b&gt;(</div><div>    pub_params: &amp;'b Self::PublicParams,</div><div>    pub_inputs: &amp;'b Self::PublicInputs,</div><div>    priv_inputs: &amp;'b Self::PrivateInputs,</div><div>    partition_count: usize,</div><div>) -&gt; Result&lt;Vec&lt;Self::Proof&gt;&gt; {</div><div>    assert!(partition_count &gt; 0);</div><div><br/></div><div>    <b>let proofs = Self::prove_layers</b>(</div><div>        &amp;pub_params.drg_porep_public_params,</div><div>        pub_inputs,</div><div>        &amp;priv_inputs.tau,</div><div>        &amp;priv_inputs.aux,</div><div>        &amp;pub_params.layer_challenges,</div><div>        pub_params.layer_challenges.layers(),</div><div>        pub_params.layer_challenges.layers(),</div><div>        partition_count,</div><div>    )?;</div><div><br/></div><div>    let mut proof_columns = vec![Vec::new(); partition_count];</div><div><br/></div><div>    for partition_proofs in proofs.into_iter() {</div><div>        for (j, proof) in partition_proofs.into_iter().enumerate() {</div><div>            proof_columns[j].push(proof);</div><div>        }</div><div>    }</div><div><br/></div><div>    let proofs = proof_columns</div><div>        .into_iter()</div><div>        .map(|p| Proof::new(p, priv_inputs.tau.clone()))</div><div>        .collect();</div><div><br/></div><div>    Ok(proofs)</div><div>}</div></div><div>返回值是每个partition的Proof结构体的collect</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Proof {</div><div>    encoding_proofs,</div><div>    tau,</div><div>}</div></div><div><br/></div><div>5.2<span style="font-weight: bold;">prove_layers</span>，storage-proofs\src\layered_drgporep.rs:244   我们可以简单理解为对每个layer的每个partition进行了一次prove并把结果放到二维数组中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn prove_layers&lt;'a&gt;(</div><div>    pp: &amp;drgporep::PublicParams&lt;Self::Hasher, Self::Graph&gt;,</div><div>    pub_inputs: &amp;PublicInputs&lt;&lt;Self::Hasher as Hasher&gt;::Domain&gt;,</div><div>    tau: &amp;[PorepTau&lt;Self::Hasher&gt;],</div><div>    aux: &amp;'a [Tree&lt;Self::Hasher&gt;],</div><div>    layer_challenges: &amp;LayerChallenges,</div><div>    layers: usize,</div><div>    total_layers: usize,</div><div>    partition_count: usize,</div><div>) -&gt; Result&lt;Vec&lt;Vec&lt;EncodingProof&lt;Self::Hasher&gt;&gt;&gt;&gt; {</div><div>    assert!(layers &gt; 0);</div><div><br/></div><div>    let mut new_pp = None;</div><div><br/></div><div>    (0..layers)</div><div>        .map(|layer| {</div><div>            let pp = match new_pp {</div><div>                Some(ref new_pp) =&gt; new_pp,</div><div>                None =&gt; pp,</div><div>            };</div><div>            let inner_layers = layers - layer;</div><div><br/></div><div>            let new_priv_inputs = drgporep::PrivateInputs {</div><div>                aux: &amp;porep::ProverAux {</div><div>                    tree_d: aux[layer].clone(),</div><div>                    tree_r: aux[layer + 1].clone(),</div><div>                },</div><div>            };</div><div>            let layer_diff = total_layers - inner_layers;</div><div><br/></div><div>            let partition_proofs: Vec&lt;_&gt; = (0..partition_count)</div><div>                .into_par_iter()</div><div>                .map(|k| {</div><div>                    let drgporep_pub_inputs = drgporep::PublicInputs {</div><div>                        replica_id: pub_inputs.replica_id,</div><div>                        challenges: pub_inputs.challenges(</div><div>                            layer_challenges,</div><div>                            pp.graph.size(),</div><div>                            layer_diff as u8,</div><div>                            Some(k),</div><div>                    ),</div><div>                    tau: Some(tau[layer]),</div><div>                };</div><div><b>                    DrgPoRep::prove(pp, &amp;drgporep_pub_inputs, &amp;new_priv_inputs)</b></div><div>                })</div><div>                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;</div><div><br/></div><div>            new_pp = Some(Self::transform(pp, layer_diff, total_layers));</div><div><br/></div><div>            Ok(partition_proofs)</div><div>        })</div><div>        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()</div><div>}</div></div><div><span style="font-weight: bold;">返回值是drgporep::Proof结构体的二维数组（在layer层我们叫他</span><span style="font-weight: bold;">EncodingProof</span><span style="font-weight: bold;">），具体请看下面drg的prove</span></div><div><font style="font-size: 10pt;"><br/></font></div><div>这里再讲一下这里的drgporep_pub_inputs，里面的replica_id和tau都是从上层搬来的不用细讲，这里值得我们关注的是这里的challenge,chanllenge最终会调用如下函数storage-proofs\src\challenge_derivation.rs ：9，这个函数主要是生成我们进行challenge的node的编号。<span style="font-weight: bold;">输入中，leaves就是我们的节点数，即data/32，k则是当前的partition的编号。commitment则是我们之前的comm_star。输出则是n个数字构成的数组。n是我们在命令行中输入的challenges，即挑战次数。</span></div><div><br/></div><div>总之就是将replicaid，commitment，layer，n，k按小字节序写出来再hash，再对节点数取模，<span style="font-weight: bold;">目前不允许挑战第一个和最后一个节点。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pub fn derive_challenges&lt;D: Domain&gt;(</div><div>    challenges: &amp;LayerChallenges,</div><div>    layer: u8,</div><div>    leaves: usize,</div><div>    replica_id: &amp;D,</div><div>    commitment: &amp;D,</div><div>    k: u8,</div><div>) -&gt; Vec&lt;usize&gt; {</div><div>    let n = challenges.challenges_for_layer(layer as usize);</div><div>    (0..n)</div><div>        .map(|i| {</div><div>            let mut bytes = replica_id.into_bytes();</div><div>            let j = ((n * k as usize) + i) as u32;</div><div>            bytes.extend(commitment.into_bytes());</div><div>            bytes.push(layer);</div><div>            bytes.write_u32::&lt;LittleEndian&gt;(j).unwrap();</div><div><br/></div><div>            let hash = blake2s(bytes.as_slice());</div><div>            let big_challenge = BigUint::from_bytes_le(hash.as_slice());</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>            let big_mod_challenge = big_challenge % (leaves - 2);</div><div>            big_mod_challenge.to_usize().unwrap() + 1</div><div>        })</div><div>        .collect()</div><div>}</div></div><div><br/></div><div>5.3.我们现在来看storage-proofs\src\drgporep.rs:256的prove，总结一下，包含三部分。</div><div>  </div><div>1.replica_nodes=r.data+r.proof</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>replica_nodes.push(DataProof {</div><div>   proof: MerkleProof::new_from_proof(&amp;tree_r.gen_proof(challenge)),</div><div>   data,</div><div>});</div></div><div>2.replica_parents=该node所有parents的（r.data+r.proof）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let parents = pub_params.graph.parents(challenge);</div><div>let mut replica_parentsi = Vec::with_capacity(parents.len());</div><div>for p in &amp;parents {</div><div>   replica_parentsi.push((*p, {</div><div>      let proof = tree_r.gen_proof(*p);</div><div>      DataProof {</div><div>         proof: MerkleProof::new_from_proof(&amp;proof),</div><div>         data: domain_replica[*p],</div><div>      }</div><div>   }));</div><div>}</div><div>replica_parents.push(replica_parentsi);</div></div><div>3.data_nodes=data<span style="font-weight: bold;">（decode的r.data）</span>+d.proof</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let node_proof = tree_d.gen_proof(challenge);</div><div><br/></div><div>{</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>let extracted = decode_domain_block::&lt;H&gt;(</div><div>   pub_params.graph.degree(),</div><div>   pub_params.sloth_iter,</div><div>   &amp;pub_inputs.replica_id,</div><div>   domain_replica,</div><div>   challenge,</div><div>   parents,</div><div>)?</div><div>.into_bytes();</div><div>data_nodes.push(DataProof {</div><div>   data: H::Domain::try_from_bytes(&amp;extracted)?,</div><div>   proof: MerkleProof::new_from_proof(&amp;node_proof),</div><div>   });</div><div> }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let proof = Proof::new(replica_nodes, replica_parents, data_nodes);</div><div>Ok(proof)</div></div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold;">prove（）返回的结构体构造如下</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Proof {</div><div>   data_root: *nodes[0].proof.root(),</div><div>   replica_root: *replica_nodes[0].proof.root(),</div><div>   replica_nodes,</div><div>   replica_parents,</div><div>   nodes,</div><div>}</div></div><div><br/></div><div>new_from_proof<span style="font-size: 10pt;">则是应用了merkle tree自带的结构里面的proof</span></div><div>D:\RUST\CARGO_HOME\git\checkouts\merkle_light-16b81cab1b05c5b8\63a609d\merkle\src\merkle.rs：97</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pub fn gen_proof(&amp;self, i: usize) -&gt; Proof&lt;T&gt; {</div><div>   assert!(i &lt; self.leafs); // i in [0 .. self.leafs)</div><div><br/></div><div>   let mut lemma: Vec&lt;T&gt; = Vec::with_capacity(self.height + 1); // path + root</div><div>   let mut path: Vec&lt;bool&gt; = Vec::with_capacity(self.height - 1); // path - 1</div><div><br/></div><div>   let mut base = 0;</div><div>   let mut j = i;</div><div><br/></div><div>   // level 1 width</div><div>   let mut width = self.leafs;</div><div>   if width &amp; 1 == 1 {</div><div>      width += 1;</div><div>   }</div><div><br/></div><div>   lemma.push(self.data[j].clone());</div><div>   while base + 1 &lt; self.len() {</div><div>      lemma.push(if j &amp; 1 == 0 {</div><div>         // j is left</div><div>         self.data[base + j + 1].clone()</div><div>      } else {</div><div>         // j is right</div><div>         self.data[base + j - 1].clone()</div><div>      });</div><div>      path.push(j &amp; 1 == 0);</div><div><br/></div><div>      base += width;</div><div>      width &gt;&gt;= 1;</div><div>      if width &amp; 1 == 1 {</div><div>         width += 1;</div><div>      }</div><div>      j &gt;&gt;= 1;</div><div>   }</div><div><br/></div><div>   // root is final</div><div>   lemma.push(self.root());</div><div>   Proof::new(lemma, path)</div><div>}</div><div><br/></div><div><br/></div></div><div>这个还是用图来说明好了</div><div><img src="zigzag.rs 运行流程 3.26ver_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>比如我们要产生2的proof，则会返回2，3，01，4567，01234567的哈希值，同时会返回从该节点到根节点的路径。</div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">6.verify </span></font> <span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span></span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">：287</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">let verified =ZigZagDrgPoRep::&lt;H&gt;::verify_all_partitions(&amp;pp, &amp;pub_inputs, &amp;all_partition_proofs).expect(&quot;failed during verification&quot;);</font></div></div><div>verify过程如下storage-proofs\src\layered_drgporep.rs：519</div><div>对每个layer的partition进行prove，并把每层的tree_r拿出来计算comm_star</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fn verify_all_partitions(</div><div>   pub_params: &amp;Self::PublicParams,</div><div>   pub_inputs: &amp;Self::PublicInputs,</div><div>   partition_proofs: &amp;[Self::Proof],</div><div>) -&gt; Result&lt;bool&gt; {</div><div>   for (k, proof) in partition_proofs.iter().enumerate() {</div><div>      if proof.encoding_proofs.len() != pub_params.layer_challenges.layers() {</div><div>         return Ok(false);</div><div>      }</div><div><br/></div><div>      let total_layers = pub_params.layer_challenges.layers();</div><div>      let mut pp = pub_params.drg_porep_public_params.clone();</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>      let mut comm_rs = Vec::new();</div><div><br/></div><div>      for (layer, proof_layer) in proof.encoding_proofs.iter().enumerate() {</div><div>         comm_rs.push(proof.tau[layer].comm_r);</div><div><br/></div><div>         let new_pub_inputs = drgporep::PublicInputs {</div><div>            replica_id: pub_inputs.replica_id,</div><div>            challenges: pub_inputs.challenges(</div><div>               &amp;pub_params.layer_challenges,</div><div>               pub_params.drg_porep_public_params.graph.size(),</div><div>               layer as u8,</div><div>               Some(k),</div><div>            ),</div><div>            tau: Some(proof.tau[layer]),</div><div>         };</div><div><br/></div><div>         let ep = &amp;proof_layer;</div><div>         let res = DrgPoRep::verify(</div><div>            &amp;pp,</div><div>            &amp;new_pub_inputs,</div><div>            &amp;drgporep::Proof {</div><div>               data_root: ep.data_root,</div><div>               replica_root: ep.replica_root,</div><div>               replica_nodes: ep.replica_nodes.clone(),</div><div>               replica_parents: ep.replica_parents.clone(),</div><div>               // TODO: investigate if clone can be avoided by using a reference </div><div>               // in drgporep::DataProof</div><div>               nodes: ep.nodes.clone(),</div><div>            },</div><div>         )?;</div><div><br/></div><div>         pp = Self::transform(&amp;pp, layer, total_layers);</div><div><br/></div><div>         if !res {</div><div>            return Ok(false);</div><div>         }</div><div>      }</div><div>      let crs = comm_r_star::&lt;L::Hasher&gt;(&amp;pub_inputs.replica_id, &amp;comm_rs)?;</div><div><br/></div><div>      if crs != pub_inputs.comm_r_star {</div><div>         return Ok(false);</div><div>      }</div><div>   }</div><div>   Ok(true)</div><div>}</div></div><div><br/></div><div><br/></div><div>其中的drg_prove结构如下：storage-proofs\src\drgporep.rs：328</div><div><br/></div><div>这里代码的可读性很好，verify总共分为三步。 </div><div>1.verify proof meta</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>{</div><div>    // This was verify_proof_meta.</div><div>    if pub_inputs.challenges[i] &gt;= pub_params.graph.size() {</div><div>        return Ok(false);</div><div>    }</div><div>    if !(proof.nodes[i].proves_challenge(pub_inputs.challenges[i])) {</div><div>        return Ok(false);</div><div>    }</div><div>    if !(proof.replica_nodes[i].proves_challenge(pub_inputs.challenges[i])) {</div><div>        return Ok(false);</div><div>    }</div><div>    let expected_parents = pub_params.graph.parents(pub_inputs.challenges[i]);</div><div>    if proof.replica_parents[i].len() != expected_parents.len() {</div><div>        println!(</div><div>            &quot;proof parents were not the same length as in public parameters: {} != {}&quot;,</div><div>            proof.replica_parents[i].len(),</div><div>            expected_parents.len()</div><div>        );</div><div>        return Ok(false);</div><div>    }</div><div>    let parents_as_expected = proof.replica_parents[i]</div><div>        .iter()</div><div>        .zip(&amp;expected_parents)</div><div>        .all(|(actual, expected)| actual.0 == *expected);</div><div>    if !parents_as_expected {</div><div>        println!(&quot;proof parents were not those provided in public parameters&quot;);</div><div>    return Ok(false);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div></div><div>2.replica_nodes和replica_parents的verify（merkel tree的verify方法）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let challenge = pub_inputs.challenges[i] % pub_params.graph.size();</div><div>assert_ne!(challenge, 0, &quot;cannot prove the first node&quot;);</div><div>if !proof.replica_nodes[i].proof.validate(challenge) {</div><div>    println!(&quot;invalid replica node&quot;);</div><div>    return Ok(false);</div><div>}</div><div>for (parent_node, p) in &amp;proof.replica_parents[i] {</div><div>    if !p.proof.validate(*parent_node) {</div><div>        println!(&quot;invalid replica parent: {:?}&quot;, p);</div><div>        return Ok(false);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div></div><div>3.对replica_nodes[i].data进行decode并与nodes[i].data进行比较</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let prover_bytes = &amp;pub_inputs.replica_id.into_bytes();</div><div><br/></div><div>let key_input =</div><div>    proof.replica_parents[i]</div><div>        .iter()</div><div>        .fold(prover_bytes.clone(), |mut acc, (_, p)| {</div><div>            acc.extend(&amp;p.data.into_bytes());</div><div>            acc</div><div>        });</div><div><br/></div><div>let key = H::kdf(key_input.as_slice(), pub_params.graph.degree());</div><div>let unsealed =</div><div>    H::sloth_decode(&amp;key, &amp;proof.replica_nodes[i].data, pub_params.sloth_iter);</div><div><br/></div><div>if unsealed != proof.nodes[i].data {</div><div>    return Ok(false);</div><div>}</div><div><br/></div><div>if !proof.nodes[i].proof.validate_data(&amp;unsealed.into_bytes()) {</div><div>    println!(&quot;invalid data for merkle path {:?}&quot;, unsealed);</div><div>    return Ok(false);</div><div>}</div></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">7.</span><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">groth    </span></span><span style="font-size: 14pt; font-weight: bold;">zigzag.rs</span><span style="font-size: 14pt; font-weight: bold;">：268</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let engine_params = JubjubBls12::new();</div><div><br/></div><div>let compound_public_params = compound_proof::PublicParams {</div><div>    vanilla_params: pp.clone(),</div><div>    engine_params: &amp;engine_params,</div><div>    partitions: Some(partitions),</div><div>};</div><div><br/></div><div><b>let gparams = ZigZagCompound::groth_params</b>(    //<b>所以gparams只和pp有关</b></div><div>    &amp;compound_public_params.vanilla_params,</div><div>    &amp;engine_params,</div><div>)</div><div>.unwrap();</div><div><br/></div><div><b>let result =</b></div><div><b>    ZigZagCompound::prove</b>(</div><div>        &amp;compound_public_params, </div><div>        &amp;pub_inputs, </div><div>        &amp;priv_inputs, </div><div>        &amp;gparams,</div><div>)</div><div>.unwrap();</div></div><div><span style="font-weight: bold;">7.1 关于groth_params的生成</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//storage-proofs\src\compound_proof.rs：188</div><div><br/></div><div>fn groth_params(</div><div>    public_params: &amp;S::PublicParams,</div><div>    engine_params: &amp;'a E::Params,</div><div>) -&gt; Result&lt;groth16::Parameters&lt;E&gt;&gt; {</div><div><b>    Self::get_groth_params(</b></div><div><b>        Self::blank_circuit(public_params, engine_params),</b></div><div><b>        public_params,</b></div><div><b>    )</b></div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//storage-proofs\src\parameter_cache.rs：120</div><div><br/></div><div>fn get_groth_params(circuit: C, pub_params: &amp;PP) -&gt; Result&lt;groth16::Parameters&lt;E&gt;&gt; {</div><div>    // Always seed the rng identically so parameter generation will be deterministic.</div><div><br/></div><div>    let id = Self::cache_identifier(pub_params);    //所以pub_params的唯一用处是拿来写路径</div><div><br/></div><div>    let generate = || {</div><div>        let rng = &amp;mut XorShiftRng::from_seed(PARAMETER_RNG_SEED);</div><div>        info!(SP_LOG, &quot;Actually generating groth params.&quot;; &quot;target&quot; =&gt; &quot;params&quot;, &quot;id&quot; =&gt; &amp;id);</div><div>        let start = Instant::now();</div><div><br/></div><div>        //groth_params生成，只和circuit有关（并且这里的circuit是</div><div>        //只有pp和engine_params = JubjubBls12::new();</div><div><b>        let parameters = groth16::generate_random_parameters::&lt;E, _, _&gt;(circuit, rng);</b></div><div><b><br/></b></div><div>        let generation_time = start.elapsed();</div><div>        info!(SP_LOG, &quot;groth_parameter_generation_time: {:?}&quot;, generation_time; &quot;target&quot; =&gt; &quot;stats&quot;, &quot;id&quot; =&gt; &amp;id);</div><div>        parameters</div><div>    };</div><div><br/></div><div>    let cache_dir = parameter_cache_dir();</div><div>    create_dir_all(cache_dir)?;</div><div>    let cache_path = parameter_cache_path(&amp;id);</div><div>    info!(SP_LOG, &quot;checking cache_path: {:?}&quot;, cache_path; &quot;target&quot; =&gt; &quot;params&quot;, &quot;id&quot; =&gt; &amp;id);</div><div><br/></div><div>    read_cached_params(&amp;cache_path).or_else(|_| {</div><div>        ensure_parent(&amp;cache_path)?;</div><div><br/></div><div>        let mut f = LockedFile::open_exclusive(&amp;cache_path)?;</div><div>        let p = generate()?;</div><div><br/></div><div>        p.write(&amp;mut f)?;</div><div>        info!(SP_LOG, &quot;wrote parameters to cache {:?} &quot;, f; &quot;target&quot; =&gt; &quot;params&quot;, &quot;id&quot; =&gt; &amp;id);</div><div><br/></div><div>        let bytes = f.seek(SeekFrom::End(0))?;</div><div>        info!(SP_LOG, &quot;groth_parameter_bytes: {}&quot;, bytes; &quot;target&quot; =&gt; &quot;stats&quot;, &quot;id&quot; =&gt; &amp;id);</div><div><br/></div><div>        Ok(p)</div><div>    })</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\generator.rs：177</div><div><br/></div><div>pub fn generate_random_parameters&lt;E, C, R&gt;(</div><div>    circuit: C,</div><div>    rng: &amp;mut R</div><div>) -&gt; Result&lt;Parameters&lt;E&gt;, SynthesisError&gt;</div><div>    where E: Engine, C: Circuit&lt;E&gt;, R: Rng</div><div>{</div><div>    let g1 = rng.gen();</div><div>    let g2 = rng.gen();</div><div>    let alpha = rng.gen();</div><div>    let beta = rng.gen();</div><div>    let gamma = rng.gen();</div><div>    let delta = rng.gen();</div><div>    let tau = rng.gen();</div><div>    generate_parameters::&lt;E, C&gt;(    //所以除了circuit全是随机生成的，groth parament生成只和pp有关系</div><div>        circuit,</div><div>        g1,</div><div>        g2,</div><div>        alpha,</div><div>        beta,</div><div>        gamma,</div><div>        delta,</div><div>        tau</div><div>    )</div><div>}</div></div><div><img src="zigzag.rs 运行流程 3.26ver_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\generator.rs：177</div><div>//groth parament的生成</div><div>//主要是计算h，l，ic。</div><div>//h，l用于在prove中计算c，ic在验证时计算input</div><div><br/></div><div>pub fn generate_parameters&lt;E, C&gt;(</div><div>    circuit: C,    //circuit中只含pp，下面的都是随机生成的</div><div>    g1: E::G1,</div><div>    g2: E::G2,</div><div>    alpha: E::Fr,</div><div>    beta: E::Fr,</div><div>    gamma: E::Fr,</div><div>    delta: E::Fr,</div><div>    tau: E::Fr</div><div>) -&gt; Result&lt;Parameters&lt;E&gt;, SynthesisError&gt;</div><div>    where E: Engine, C: Circuit&lt;E&gt;</div><div>{</div><div>    let mut assembly = KeypairAssembly {</div><div>        num_inputs: 0,</div><div>        num_aux: 0,</div><div>        num_constraints: 0,     //m</div><div>        at_inputs: vec![],     <b>//input-statements</b></div><div>        bt_inputs: vec![],</div><div>        ct_inputs: vec![],</div><div>        at_aux: vec![],   <b> </b><b>//aux-witness</b></div><div>        bt_aux: vec![],</div><div>        ct_aux: vec![]</div><div>    };</div><div><br/></div><div>    // Allocate the &quot;one&quot; input variable</div><div>    assembly.alloc_input(|| &quot;&quot;, || Ok(E::Fr::one()))?;</div><div><br/></div><div>    // Synthesize the circuit into a rank-1 quadratic constraint system</div><div>    circuit.synthesize(&amp;mut assembly)?;</div><div><br/></div><div>    // Input constraints to ensure full density of IC query</div><div>    // x * 0 = 0</div><div>    for i in 0..assembly.num_inputs {</div><div>        assembly.enforce(|| &quot;&quot;,</div><div>            |lc| lc + Variable(Index::Input(i)),</div><div>            |lc| lc,</div><div>            |lc| lc,</div><div>        );</div><div>    }</div><div><br/></div><div>    // Create bases for blind evaluation of polynomials at tau</div><div>    let powers_of_tau = vec![Scalar::&lt;E&gt;(E::Fr::zero()); assembly.num_constraints];</div><div>    let mut powers_of_tau = EvaluationDomain::from_coeffs(powers_of_tau)?;</div><div><br/></div><div>    // Compute G1 window table</div><div>    let mut g1_wnaf = Wnaf::new();</div><div>    let g1_wnaf = g1_wnaf.base(g1, {</div><div>        // H query</div><div>        (powers_of_tau.as_ref().len() - 1)</div><div>        // IC/L queries</div><div>        + assembly.num_inputs + assembly.num_aux</div><div>        // A query</div><div>        + assembly.num_inputs + assembly.num_aux</div><div>        // B query</div><div>        + assembly.num_inputs + assembly.num_aux</div><div>    });</div><div><br/></div><div><br/></div><div>    // Compute G2 window table</div><div>    let mut g2_wnaf = Wnaf::new();</div><div>    let g2_wnaf = g2_wnaf.base(g2, {</div><div>        // B query</div><div>        assembly.num_inputs + assembly.num_aux</div><div>    });</div><div><br/></div><div>    let gamma_inverse = gamma.inverse().ok_or(SynthesisError::UnexpectedIdentity)?;</div><div>    let delta_inverse = delta.inverse().ok_or(SynthesisError::UnexpectedIdentity)?;</div><div><br/></div><div>    let worker = Worker::new();</div><div><br/></div><div>    let mut h = vec![E::G1::zero(); powers_of_tau.as_ref().len() - 1];</div><div>    {</div><div>        // Compute powers of tau</div><div>        {</div><div>            let powers_of_tau = powers_of_tau.as_mut();</div><div>            worker.scope(powers_of_tau.len(), |scope, chunk| {</div><div>                for (i, powers_of_tau) in powers_of_tau.chunks_mut(chunk).enumerate()</div><div>                {</div><div>                    scope.spawn(move |_| {</div><div>                        let mut current_tau_power = tau.pow(&amp;[(i*chunk) as u64]);</div><div><br/></div><div>                        for p in powers_of_tau {</div><div>                            p.0 = current_tau_power;</div><div>                            current_tau_power.mul_assign(&amp;tau);</div><div>                        }</div><div>                    });</div><div>                }</div><div>            }).unwrap();</div><div>        }</div><div><br/></div><div><br/></div><div>        // coeff = t(x) / delta</div><div>        let mut coeff = powers_of_tau.z(&amp;tau);</div><div>        coeff.mul_assign(&amp;delta_inverse);</div><div><br/></div><div><br/></div><div>        // Compute the H query with multiple threads</div><div>        worker.scope(h.len(), |scope, chunk| {</div><div>            for (h, p) in h.chunks_mut(chunk).zip(powers_of_tau.as_ref().chunks(chunk))</div><div>            {</div><div>                let mut g1_wnaf = g1_wnaf.shared();</div><div><br/></div><div>                scope.spawn(move |_| {</div><div>                    // Set values of the H query to g1^{(tau^i * t(tau)) / delta}</div><div>                    for (h, p) in h.iter_mut().zip(p.iter())</div><div>                    {</div><div>                        // Compute final exponent</div><div>                        let mut exp = p.0;</div><div>                        exp.mul_assign(&amp;coeff);</div><div><br/></div><div>                        // Exponentiate</div><div>                        *h = g1_wnaf.scalar(exp.into_repr());</div><div>                    }</div><div><br/></div><div>                    // Batch normalize</div><div>                    E::G1::batch_normalization(h);</div><div>                });    </div><div>            }</div><div>        }).unwrap();</div><div>    }</div><div><br/></div><div><br/></div><div>    // Use inverse FFT to convert powers of tau to Lagrange coefficients</div><div>    powers_of_tau.ifft(&amp;worker);</div><div>    let powers_of_tau = powers_of_tau.into_coeffs();</div><div><br/></div><div><br/></div><div>    let mut a = vec![E::G1::zero(); assembly.num_inputs + assembly.num_aux];</div><div>    let mut b_g1 = vec![E::G1::zero(); assembly.num_inputs + assembly.num_aux];</div><div>    let mut b_g2 = vec![E::G2::zero(); assembly.num_inputs + assembly.num_aux];</div><div>    let mut ic = vec![E::G1::zero(); assembly.num_inputs];</div><div>    let mut l = vec![E::G1::zero(); assembly.num_aux];</div><div><br/></div><div><br/></div><div>    fn eval&lt;E: Engine&gt;(</div><div>        // wNAF window tables</div><div>        g1_wnaf: &amp;Wnaf&lt;usize, &amp;[E::G1], &amp;mut Vec&lt;i64&gt;&gt;,</div><div>        g2_wnaf: &amp;Wnaf&lt;usize, &amp;[E::G2], &amp;mut Vec&lt;i64&gt;&gt;,</div><div><br/></div><div>        // Lagrange coefficients for tau</div><div>        powers_of_tau: &amp;[Scalar&lt;E&gt;],</div><div><br/></div><div>        // QAP polynomials</div><div>        at: &amp;[Vec&lt;(E::Fr, usize)&gt;],</div><div>        bt: &amp;[Vec&lt;(E::Fr, usize)&gt;],</div><div>        ct: &amp;[Vec&lt;(E::Fr, usize)&gt;],</div><div><br/></div><div>        // Resulting evaluated QAP polynomials</div><div>        a: &amp;mut [E::G1],</div><div>        b_g1: &amp;mut [E::G1],</div><div>        b_g2: &amp;mut [E::G2],</div><div>        ext: &amp;mut [E::G1],</div><div><br/></div><div>        // Inverse coefficient for ext elements，ext元素的逆系数</div><div>        inv: &amp;E::Fr,</div><div><br/></div><div>        // Trapdoors</div><div>        alpha: &amp;E::Fr,</div><div>        beta: &amp;E::Fr,</div><div><br/></div><div>        // Worker</div><div>        worker: &amp;Worker</div><div>    )</div><div>    {</div><div>        // Sanity check，完整性检查</div><div>        assert_eq!(a.len(), at.len());</div><div>        assert_eq!(a.len(), bt.len());</div><div>        assert_eq!(a.len(), ct.len());</div><div>        assert_eq!(a.len(), b_g1.len());</div><div>        assert_eq!(a.len(), b_g2.len());</div><div>        assert_eq!(a.len(), ext.len());</div><div><br/></div><div>        // Evaluate polynomials in multiple threads</div><div>        worker.scope(a.len(), |scope, chunk| {</div><div>            for ((((((a, b_g1), b_g2), ext), at), bt), ct) in a.chunks_mut(chunk)</div><div>                                                               .zip(b_g1.chunks_mut(chunk))</div><div>                                                              .zip(b_g2.chunks_mut(chunk))</div><div>                                                              .zip(ext.chunks_mut(chunk))</div><div>                                                              .zip(at.chunks(chunk))</div><div>                                                              .zip(bt.chunks(chunk))</div><div>                                                              .zip(ct.chunks(chunk))</div><div>            {</div><div>                let mut g1_wnaf = g1_wnaf.shared();</div><div>                let mut g2_wnaf = g2_wnaf.shared();</div><div><br/></div><div>                scope.spawn(move |_| {</div><div>                    for ((((((a, b_g1), b_g2), ext), at), bt), ct) in a.iter_mut()</div><div>                                                                       .zip(b_g1.iter_mut())</div><div>                                                                       .zip(b_g2.iter_mut())</div><div>                                                                       .zip(ext.iter_mut())</div><div>                                                                       .zip(at.iter())</div><div>                                                                       .zip(bt.iter())</div><div>                                                                       .zip(ct.iter())</div><div>                    {</div><div>                        fn eval_at_tau&lt;E: Engine&gt;(</div><div>                            powers_of_tau: &amp;[Scalar&lt;E&gt;],</div><div>                            p: &amp;[(E::Fr, usize)]</div><div>                        ) -&gt; E::Fr</div><div>                        {</div><div>                            let mut acc = E::Fr::zero();</div><div><br/></div><div>                            for &amp;(ref coeff, index) in p {</div><div>                                let mut n = powers_of_tau[index].0;</div><div>                                n.mul_assign(coeff);</div><div>                                acc.add_assign(&amp;n);</div><div>                            }</div><div><br/></div><div>                            acc</div><div>                        }</div><div><br/></div><div>                        // Evaluate QAP polynomials at tau，计算多项式在tau的数值</div><div>                        let mut at = eval_at_tau(powers_of_tau, at);</div><div>                        let mut bt = eval_at_tau(powers_of_tau, bt);</div><div>                        let ct = eval_at_tau(powers_of_tau, ct);</div><div><br/></div><div>                        // Compute A query (in G1)</div><div>                        if !at.is_zero() {</div><div>                            *a = g1_wnaf.scalar(at.into_repr());</div><div>                        }</div><div>                        // Compute B query (in G1/G2)</div><div>                        if !bt.is_zero() {</div><div>                            let bt_repr = bt.into_repr();</div><div>                            *b_g1 = g1_wnaf.scalar(bt_repr);</div><div>                            *b_g2 = g2_wnaf.scalar(bt_repr);</div><div>                        }</div><div><br/></div><div>                        at.mul_assign(&amp;beta);</div><div>                        bt.mul_assign(&amp;alpha);</div><div><br/></div><div>                        let mut e = at;</div><div>                        e.add_assign(&amp;bt);</div><div>                        e.add_assign(&amp;ct);</div><div>                        e.mul_assign(inv);</div><div><br/></div><div>                        *ext = g1_wnaf.scalar(e.into_repr());</div><div>                    }</div><div><br/></div><div><br/></div><div>                    // Batch normalize，规范化，更加有利于仿射计算</div><div>                    E::G1::batch_normalization(a);</div><div>                    E::G1::batch_normalization(b_g1);</div><div>                    E::G2::batch_normalization(b_g2);</div><div>                    E::G1::batch_normalization(ext);</div><div>                });</div><div>            }</div><div>        }).unwrap();</div><div>    }</div><div><br/></div><div><br/></div><div>    // Evaluate for inputs.</div><div>    eval(</div><div>        &amp;g1_wnaf,</div><div>        &amp;g2_wnaf,</div><div>        &amp;powers_of_tau,</div><div>        &amp;assembly.at_inputs,</div><div>        &amp;assembly.bt_inputs,</div><div>        &amp;assembly.ct_inputs,</div><div>        &amp;mut a[0..assembly.num_inputs],</div><div>        &amp;mut b_g1[0..assembly.num_inputs],</div><div>        &amp;mut b_g2[0..assembly.num_inputs],</div><div>        &amp;mut ic,</div><div>        &amp;gamma_inverse,</div><div>        &amp;alpha,</div><div>        &amp;beta,</div><div>        &amp;worker</div><div>    );</div><div><br/></div><div><br/></div><div>    // Evaluate for auxillary variables.</div><div>    eval(</div><div>        &amp;g1_wnaf,</div><div>        &amp;g2_wnaf,</div><div>        &amp;powers_of_tau,</div><div>        &amp;assembly.at_aux,</div><div>        &amp;assembly.bt_aux,</div><div>        &amp;assembly.ct_aux,</div><div>        &amp;mut a[assembly.num_inputs..],</div><div>        &amp;mut b_g1[assembly.num_inputs..],</div><div>        &amp;mut b_g2[assembly.num_inputs..],</div><div>        &amp;mut l,</div><div>        &amp;delta_inverse,</div><div>        &amp;alpha,</div><div>        &amp;beta,</div><div>        &amp;worker</div><div>    );</div><div><br/></div><div><br/></div><div>    // Don't allow any elements be unconstrained, so that</div><div>    // the L query is always fully dense.</div><div>    for e in l.iter() {</div><div>        if e.is_zero() {</div><div>            return Err(SynthesisError::UnconstrainedVariable);</div><div>        }</div><div>    }</div><div><br/></div><div>    let g1 = g1.into_affine();</div><div>    let g2 = g2.into_affine();</div><div><br/></div><div>    let vk = VerifyingKey::&lt;E&gt; {</div><div>        alpha_g1: g1.mul(alpha).into_affine(),</div><div>        beta_g1: g1.mul(beta).into_affine(),</div><div>        beta_g2: g2.mul(beta).into_affine(),</div><div>        gamma_g2: g2.mul(gamma).into_affine(),</div><div>        delta_g1: g1.mul(delta).into_affine(),</div><div>        delta_g2: g2.mul(delta).into_affine(),</div><div><br/></div><div>       <b> </b><b>//(beta * at_inputs(tau) + alpha * bt_inputs(tau) + ct_inputs(tau)) / gamma for all inputs</b></div><div>        ic: ic.into_iter().map(|e| e.into_affine()).collect()</div><div>    };</div><div><br/></div><div><br/></div><div>    Ok(Parameters {</div><div>        vk: vk,</div><div><b>        //((tau^i * t(tau)) / delta) num_constraints</b></div><div>        h: Arc::new(h.into_iter().map(|e| e.into_affine()).collect()),</div><div><br/></div><div><b>        //(beta * at_aux(tau) + alpha * bt_aux(tau) + ct_aux(tau)) / delta for all auxillary</b></div><div>        l: Arc::new(l.into_iter().map(|e| e.into_affine()).collect()),</div><div><br/></div><div>        // Filter points at infinity away from A/B queries</div><div>        a: Arc::new(a.into_iter().filter(|e| !e.is_zero()).map(|e| e.into_affine()).collect()),</div><div>        b_g1: Arc::new(b_g1.into_iter().filter(|e| !e.is_zero()).map(|e| e.into_affine()).collect()),</div><div>        b_g2: Arc::new(b_g2.into_iter().filter(|e| !e.is_zero()).map(|e| e.into_affine()).collect())</div><div>    })</div><div>}</div></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">计算得到以下结构</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\mod.rs：216</div><div><br/></div><div>pub struct <b>Parameters</b>&lt;E: Engine&gt; {</div><div><br/></div><div>   <b> </b><b>pub vk: VerifyingKey&lt;E&gt;,</b></div><div><br/></div><div>    // Elements of the form ((tau^i * t(tau)) / delta) for i between 0 and</div><div>    // m-2 inclusive. Never contains points at infinity.</div><div>   <b> </b><b>pub h: Arc&lt;Vec&lt;E::G1Affine&gt;&gt;,</b></div><div><br/></div><div>    // Elements of the form (beta * u_i(tau) + alpha * v_i(tau) + w_i(tau)) / delta</div><div>    // for all auxillary inputs. Variables can never be unconstrained, so this</div><div>    // never contains points at infinity.</div><div><b>    pub l: Arc&lt;Vec&lt;E::G1Affine&gt;&gt;,</b></div><div><br/></div><div>    // QAP &quot;A&quot; polynomials evaluated at tau in the Lagrange basis. Never contains</div><div>    // points at infinity: polynomials that evaluate to zero are omitted from</div><div>    // the CRS and the prover can deterministically skip their evaluation.</div><div><b>    pub a: Arc&lt;Vec&lt;E::G1Affine&gt;&gt;,</b></div><div><br/></div><div>    // QAP &quot;B&quot; polynomials evaluated at tau in the Lagrange basis. Needed in</div><div>    // G1 and G2 for C/B queries, respectively. Never contains points at</div><div>    // infinity for the same reason as the &quot;A&quot; polynomials.</div><div><b>    pub b_g1: Arc&lt;Vec&lt;E::G1Affine&gt;&gt;,</b></div><div><b>    pub b_g2: Arc&lt;Vec&lt;E::G2Affine&gt;&gt;</b></div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\mod.rs：101</div><div><br/></div><div>pub struct VerifyingKey&lt;E: Engine&gt; {</div><div><br/></div><div>    // alpha in g1 for verifying and for creating A/C elements of</div><div>    // proof. Never the point at infinity.</div><div><b>    pub alpha_g1: E::G1Affine,</b></div><div><br/></div><div>    // beta in g1 and g2 for verifying and for creating B/C elements</div><div>    // of proof. Never the point at infinity.</div><div><b>    pub beta_g1: E::G1Affine,</b></div><div><b>    pub beta_g2: E::G2Affine,</b></div><div><br/></div><div>    // gamma in g2 for verifying. Never the point at infinity.</div><div><b>    pub gamma_g2: E::G2Affine,</b></div><div><br/></div><div>    // delta in g1/g2 for verifying and proving, essentially the magic</div><div>    // trapdoor that forces the prover to evaluate the C element of the    </div><div>    // proof with only components from the CRS. Never the point at</div><div>    // infinity.</div><div><b>    pub delta_g1: E::G1Affine,</b></div><div><b>    pub delta_g2: E::G2Affine,</b></div><div><br/></div><div>    // Elements of the form (beta * u_i(tau) + alpha * v_i(tau) + w_i(tau)) / gamma</div><div>    // for all public inputs. Because all public inputs have a dummy constraint,</div><div>    // this is the same size as the number of inputs, and never contains points    </div><div>    // at infinity.</div><div><b>    pub ic: Vec&lt;E::G1Affine&gt;</b></div><div>}</div><div><br/></div><div><br/></div></div><div><br/></div><div><span style="font-weight: bold;">7.2 prove </span></div><div><br/></div><div>参考文档：</div><div><a href="https://blog.coinfabrik.com/wp-content/uploads/2017/03/zkSNARK-explained_basic_principles.pdf">https://blog.coinfabrik.com/wp-content/uploads/2017/03/zkSNARK-explained_basic_principles.pdf</a></div><div><a href="https://www.jianshu.com/p/7b772e5cdaef">https://www.jianshu.com/p/7b772e5cdaef</a></div><div><a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6</a></div><div><a href="https://z.cash/technology/zksnarks">https://z.cash/technology/zksnarks</a></div><div><span style="box-sizing: border-box; font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(33, 37, 41); font-family: robotomedium, Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Computation → Arithmetic Circuit → R1CS → QAP → zk-SNARK</span></div><div><br/></div><div><span style="font-weight: bold;">storage-proofs\src\compound_proof.rs:70的fn prove</span></div><div>1.参数配置</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let partitions = Self::partition_count(pub_params);</div><div>let partition_count = Self::partition_count(pub_params);</div><div><br/></div><div>let vanilla_proofs =</div><div>    S::prove_all_partitions(&amp;pub_params.vanilla_params, &amp;pub_in, priv_in, partitions)?;</div><div><br/></div><div>let sanity_check =</div><div>    S::verify_all_partitions(&amp;pub_params.vanilla_params, &amp;pub_in, &amp;vanilla_proofs)?;</div><div>assert!(sanity_check, &quot;sanity check failed&quot;);</div><div><br/></div><div>assert!(partition_count &gt; 0);</div></div><div>2.调用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let groth_proofs: Result&lt;Vec&lt;_&gt;&gt; = vanilla_proofs</div><div>    .par_iter()</div><div>    .map(|vanilla_proof| {        //对vanilla_proofs进行iter，即每个partition进行一次circuit_proof</div><div>                                  //然后进行collect</div><div>        <b>Self::circuit_proof</b>(</div><div><b>            pub_in,</b></div><div><b>            &amp;vanilla_proof,</b></div><div><b>            &amp;pub_params.vanilla_params,</b></div><div><b>            &amp;pub_params.engine_params,</b></div><div><b>            &amp;groth_params,</b></div><div>        )</div><div>    })</div><div>    .collect();</div><div><br/></div><div>Ok(MultiProof::new(groth_proofs?, &amp;groth_params.vk))</div></div><div>3.返回值</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pub struct MultiProof&lt;E: Engine&gt; {</div><div>    pub circuit_proofs: Vec&lt;groth16::Proof&lt;E&gt;&gt;,</div><div>    pub verifying_key: groth16::VerifyingKey&lt;E&gt;,</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//storage-proofs\src\compound_proof.rs：135</div><div>fn circuit_proof&lt;'b&gt;(</div><div>    pub_in: &amp;S::PublicInputs,</div><div>    vanilla_proof: &amp;S::Proof,</div><div>    pub_params: &amp;'b S::PublicParams,</div><div>    params: &amp;'a E::Params,</div><div>    groth_params: &amp;groth16::Parameters&lt;E&gt;,</div><div>) -&gt; Result&lt;groth16::Proof&lt;E&gt;&gt; {</div><div>    let rng = &amp;mut OsRng::new().unwrap();</div><div><br/></div><div>    // We need to make the circuit repeatedly because we can't clone it.</div><div>    // Fortunately, doing so is cheap.</div><div><br/></div><div>    let make_circuit = || {</div><div>        Self::circuit(</div><div><b>            &amp;pub_in,</b></div><div><b>            C::ComponentPrivateInputs::default(),</b></div><div><b>            &amp;vanilla_proof,</b></div><div><b>            &amp;pub_params,</b></div><div><b>            &amp;params,</b></div><div>        )</div><div>    };</div><div><br/></div><div><b>    let groth_proof = groth16::create_random_proof(make_circuit(), groth_params, rng)?;</b></div><div><br/></div><div>    let mut proof_vec = vec![];</div><div>    groth_proof.write(&amp;mut proof_vec)?;</div><div>    let gp = groth16::Proof::&lt;E&gt;::read(&amp;proof_vec[..])?;</div><div><br/></div><div>    Ok(gp)</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\prover.rs：194</div><div>pub fn create_random_proof&lt;E, C, R, P: ParameterSource&lt;E&gt;&gt;(</div><div>    circuit: C,</div><div>    params: P,</div><div>    rng: &amp;mut R</div><div>) -&gt; Result&lt;Proof&lt;E&gt;, SynthesisError&gt;</div><div>    where E: Engine, C: Circuit&lt;E&gt;, R: Rng</div><div>{</div><div>    let r = rng.gen();</div><div>    let s = rng.gen();</div><div><br/></div><div>    create_proof::&lt;E, C, P&gt;(circuit, params, r, s)</div><div>}</div></div><div><br/></div><div><img src="zigzag.rs 运行流程 3.26ver_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//计算a，b，c作为Proof，上层再和vk一起打包</div><div><br/></div><div>pub fn create_proof&lt;E, C, P: ParameterSource&lt;E&gt;&gt;(</div><div>    circuit: C,</div><div>    mut params: P,</div><div>    r: E::Fr,</div><div>    s: E::Fr</div><div>) -&gt; Result&lt;Proof&lt;E&gt;, SynthesisError&gt;</div><div>    where E: Engine, C: Circuit&lt;E&gt;</div><div>{</div><div>    let mut prover = ProvingAssignment {</div><div>        a_aux_density: DensityTracker::new(),</div><div>        b_input_density: DensityTracker::new(),</div><div>        b_aux_density: DensityTracker::new(),</div><div>        a: vec![],</div><div>        b: vec![],</div><div>        c: vec![],</div><div>        input_assignment: vec![],</div><div>        aux_assignment: vec![]</div><div>    };</div><div><br/></div><div>    // Allocate the &quot;one&quot; input variable</div><div>    prover.alloc_input(|| &quot;&quot;, || Ok(E::Fr::one()))?;</div><div><br/></div><div>    // Synthesize the circuit into a rank-1 quadratic constraint system</div><div>    circuit.synthesize(&amp;mut prover)?;</div><div><br/></div><div>    // Input constraints to ensure full density of IC query</div><div>    // x * 0 = 0</div><div>    for i in 0..prover.input_assignment.len() {</div><div>        prover.enforce(|| &quot;&quot;,</div><div>            |lc| lc + Variable(Index::Input(i)),</div><div>            |lc| lc,</div><div>            |lc| lc,</div><div>        );</div><div>    }</div><div><br/></div><div>    let worker = Worker::new();</div><div><br/></div><div>    let vk = params.get_vk(prover.input_assignment.len())?;</div><div><br/></div><div>    let h = {</div><div>        let mut a = EvaluationDomain::from_coeffs(prover.a)?;</div><div>        let mut b = EvaluationDomain::from_coeffs(prover.b)?;</div><div>        let mut c = EvaluationDomain::from_coeffs(prover.c)?;</div><div>        //对abc多项式做 ifft - distribute_powers -fft</div><div>        a.ifft(&amp;worker);</div><div>        a.coset_fft(&amp;worker);</div><div>        b.ifft(&amp;worker);</div><div>        b.coset_fft(&amp;worker);</div><div>        c.ifft(&amp;worker);</div><div>        c.coset_fft(&amp;worker);</div><div><br/></div><div>        a.mul_assign(&amp;worker, &amp;b);</div><div>        drop(b);</div><div>        a.sub_assign(&amp;worker, &amp;c);</div><div>        drop(c);</div><div>        a.divide_by_z_on_coset(&amp;worker);</div><div>        a.icoset_fft(&amp;worker);</div><div>        let mut a = a.into_coeffs();</div><div>        let a_len = a.len() - 1;</div><div>        a.truncate(a_len);</div><div><br/></div><div>        let a = Arc::new(a.into_iter().map(|s| s.0.into_repr()).collect::&lt;Vec&lt;_&gt;&gt;());</div><div><br/></div><div>        multiexp(&amp;worker, params.get_h(a.len())?, FullDensity, a)</div><div>    };</div><div><br/></div><div>    // TODO: parallelize if it's even helpful</div><div>    let input_assignment = Arc::new(prover.input_assignment.into_iter().map(|s| s.into_repr()).collect::&lt;Vec&lt;_&gt;&gt;());</div><div>    let aux_assignment = Arc::new(prover.aux_assignment.into_iter().map(|s| s.into_repr()).collect::&lt;Vec&lt;_&gt;&gt;());</div><div><br/></div><div>    let l = multiexp(&amp;worker, params.get_l(aux_assignment.len())?, FullDensity, aux_assignment.clone());</div><div><br/></div><div>    let a_aux_density_total = prover.a_aux_density.get_total_density();</div><div>    let (a_inputs_source, a_aux_source) = params.get_a(input_assignment.len(), a_aux_density_total)?;</div><div>    let a_inputs = multiexp(&amp;worker, a_inputs_source, FullDensity, input_assignment.clone());</div><div>    let a_aux = multiexp(&amp;worker, a_aux_source, Arc::new(prover.a_aux_density), aux_assignment.clone());</div><div><br/></div><div>    let b_input_density = Arc::new(prover.b_input_density);</div><div>    let b_input_density_total = b_input_density.get_total_density();</div><div>    let b_aux_density = Arc::new(prover.b_aux_density);</div><div>    let b_aux_density_total = b_aux_density.get_total_density();</div><div><br/></div><div><br/></div><div>    let (b_g1_inputs_source, b_g1_aux_source) = params.get_b_g1(b_input_density_total, b_aux_density_total)?;</div><div>    let b_g1_inputs = multiexp(&amp;worker, b_g1_inputs_source, b_input_density.clone(), input_assignment.clone());</div><div>    let b_g1_aux = multiexp(&amp;worker, b_g1_aux_source, b_aux_density.clone(), aux_assignment.clone());</div><div><br/></div><div>    let (b_g2_inputs_source, b_g2_aux_source) = params.get_b_g2(b_input_density_total, b_aux_density_total)?;</div><div>    let b_g2_inputs = multiexp(&amp;worker, b_g2_inputs_source, b_input_density, input_assignment);</div><div>    let b_g2_aux = multiexp(&amp;worker, b_g2_aux_source, b_aux_density, aux_assignment);</div><div><br/></div><div><br/></div><div>    if vk.delta_g1.is_zero() || vk.delta_g2.is_zero() {</div><div>        // If this element is zero, someone is trying to perform a</div><div>        // subversion-CRS attack.</div><div>        return Err(SynthesisError::UnexpectedIdentity);</div><div>    }</div><div><br/></div><div><br/></div><div>    let mut g_a = vk.delta_g1.mul(r);</div><div>    g_a.add_assign_mixed(&amp;vk.alpha_g1);</div><div>    let mut g_b = vk.delta_g2.mul(s);</div><div>    g_b.add_assign_mixed(&amp;vk.beta_g2);</div><div>    let mut g_c;</div><div>    {</div><div>        let mut rs = r;</div><div>        rs.mul_assign(&amp;s);</div><div><br/></div><div>        g_c = vk.delta_g1.mul(rs);</div><div>        g_c.add_assign(&amp;vk.alpha_g1.mul(s));</div><div>        g_c.add_assign(&amp;vk.beta_g1.mul(r));</div><div>    }</div><div><br/></div><div>    let mut a_answer = a_inputs.wait()?;</div><div>    a_answer.add_assign(&amp;a_aux.wait()?);</div><div>    g_a.add_assign(&amp;a_answer);</div><div>    a_answer.mul_assign(s);</div><div>    g_c.add_assign(&amp;a_answer);</div><div><br/></div><div>    let mut b1_answer = b_g1_inputs.wait()?;</div><div>    b1_answer.add_assign(&amp;b_g1_aux.wait()?);</div><div>    let mut b2_answer = b_g2_inputs.wait()?;</div><div>    b2_answer.add_assign(&amp;b_g2_aux.wait()?);</div><div><br/></div><div>    g_b.add_assign(&amp;b2_answer);</div><div>    b1_answer.mul_assign(r);</div><div><br/></div><div>    g_c.add_assign(&amp;b1_answer);</div><div>    g_c.add_assign(&amp;h.wait()?);</div><div>    g_c.add_assign(&amp;l.wait()?);</div><div><br/></div><div>    Ok(Proof {</div><div>        a: g_a.into_affine(),</div><div>        b: g_b.into_affine(),</div><div>        c: g_c.into_affine()</div><div>    })</div><div>}</div><div><br/></div><div><br/></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\mod.rs：28</div><div>pub struct Proof&lt;E: Engine&gt; {</div><div>    pub a: E::G1Affine,</div><div>    pub b: E::G2Affine,</div><div>    pub c: E::G1Affine</div><div>}</div></div><div><span style="font-weight: bold;">7.3 verify</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//filecoin-proofs\examples\zigzag.rs：380</div><div>ZigZagCompound::verify(&amp;compound_public_params, &amp;pub_inputs, &amp;multi_proof).unwrap();</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>storage-proofs\src\compound_proof.rs：109</div><div>fn verify(</div><div>    public_params: &amp;PublicParams&lt;'a, E, S&gt;,</div><div>    public_inputs: &amp;S::PublicInputs,</div><div>    multi_proof: &amp;MultiProof&lt;E&gt;,</div><div>) -&gt; Result&lt;bool&gt; {</div><div>    let vanilla_public_params = &amp;public_params.vanilla_params;</div><div><b>    let pvk = groth16::prepare_verifying_key(&amp;multi_proof.verifying_key);</b></div><div>    if multi_proof.circuit_proofs.len() != Self::partition_count(public_params) {</div><div>        return Ok(false);</div><div>    }</div><div><br/></div><div>    for (k, circuit_proof) in multi_proof.circuit_proofs.iter().enumerate() {</div><div>        let <b>inputs =Self::generate_public_inputs(public_inputs, vanilla_public_params, Some(k));</b></div><div><br/></div><div>        if !<b>groth16::verify_proof(&amp;pvk, &amp;circuit_proof, inputs.as_slice())?</b> {</div><div>            return Ok(false);</div><div>        }</div><div>    }</div><div>    Ok(true)</div><div>}</div></div><div><br/></div><div><img src="zigzag.rs 运行流程 3.26ver_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//</span>CARGO_HOME\git\checkouts\bellman-bfff4baef5e54429\e092cca\src\groth16\verifier.rs：36</div><div>pub fn verify_proof&lt;'a, E: Engine&gt;(</div><div>    pvk: &amp;'a PreparedVerifyingKey&lt;E&gt;,</div><div>    proof: &amp;Proof&lt;E&gt;,</div><div>    public_inputs: &amp;[E::Fr]</div><div>) -&gt; Result&lt;bool, SynthesisError&gt;</div><div>{</div><div>    if (public_inputs.len() + 1) != pvk.ic.len() {</div><div>        return Err(SynthesisError::MalformedVerifyingKey);</div><div>    }</div><div><br/></div><div>    let mut acc = pvk.ic[0].into_projective();</div><div><br/></div><div>    for (i, b) in public_inputs.iter().zip(pvk.ic.iter().skip(1)) {</div><div>        acc.add_assign(&amp;b.mul(i.into_repr()));</div><div>    }</div><div><br/></div><div>    // The verification equation is:</div><div>    // A * B + inputs * (-gamma) + C * (-delta) = alpha * beta</div><div><br/></div><div>    Ok(E::final_exponentiation(</div><div>        &amp;E::miller_loop([</div><div>            (&amp;proof.a.prepare(), &amp;proof.b.prepare()),</div><div>            (&amp;acc.into_affine().prepare(), &amp;pvk.neg_gamma_g2),</div><div>            (&amp;proof.c.prepare(), &amp;pvk.neg_delta_g2)</div><div>        ].into_iter())</div><div>    ).unwrap() == pvk.alpha_g1_beta_g2)</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 