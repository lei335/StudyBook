# 关于secp256k1和ECDSA

`@author zl`

参考文章：[一文读懂ECDSA算法如何保护数据](https://zhuanlan.zhihu.com/p/97953640)

[指南：关于secp256k1、ECDH、ECDSA | 登链社区 | 区块链技术社区](https://learnblockchain.cn/article/5189)

***

## 详解ECDSA算法

椭圆曲线数字签名算法（ECDSA）用于对数据进行签名，比特币和以太坊都采用该算法。

***

**公开参数**：a, b, p, N, G

其中，椭圆曲线方程式为：$y^2 = (x^3 + ax + b)\,mod\,p$

N表示这条椭圆曲线上的节点数目（x, y都为整数），G表示这条椭圆曲线上的一个节点。

椭圆曲线上的加法计算为：

点A与点B的和即为两点连线与曲线的第三个交点关于x轴的对称点。

椭圆曲线上的乘法为：

点A乘以k，即为k个A依次相加（切线交点）。

一个椭圆曲线乘法的特性是你有一个点$R=k*P$，你知道R和P，但是你无法据此求出k，因为这里没有椭圆曲线减法或者除法可用。这一原则也被称为 **单向陷门函数**。

**签名者**：

需要有一对公钥和私钥，私钥是一个32字节大小的随机数，公钥是点G与私钥相乘以后曲线上的点。dA表示私钥，Qa表示公钥，其中$Qa=dA*G$。

**签名的过程**：

首先签名信息有64字节，由两个均为32字节的值R、S构成。除了公开参数，你还需要：

1. 产生一个随机数k,32字节
2. 得到$P=k*G$
3. 点P的x坐标即为R
4. 利用SHA哈希算法计算被签名信息的哈希值z
5. 计算$S=k^{-1}(z+dA*R)\,\,(mod\,p)$

其中$k^{-1}$是k的[模的乘法逆元](https://aaron67.cc/2020/05/30/modular-multiplicative-inverse/)，即$(k^{-1} * k)\,mod\,p\,=\,1$ 

**验证签名**：

除了知道公开参数，还需要知道签名者的公钥Qa、信息哈希值z、签名信息(R,S)。

计算点P：$P=S^{-1}*z*G+S^{-1}*R*Qa$

如果点P的x坐标与R相等，则意味着这个签名是有效的，否则无效。

其中，随机数k应该保密且保证每笔签名中k应该是加密随机的。如果每次签名都使用同样的k，那么将会让其他人很容易计算出该k值，进而就能够计算出私钥dA，这是非常危险的。这表明了每次签名时使用真正随机数的重要性，因为如果$(R,S)$签名对的R值在两个不同签名上相同，则会暴露私钥。

## Secp256k1

比特币和以太坊选择的椭圆曲线都是secp256k1曲线。secp256k1为基于Fp有限域上的椭圆曲线。

secp256k1曲线方程式为

  $y^2 = (x^3 + 7)\,mod\,p$

即a=0,b=7,其中  $p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1=2^{256}-2^{32}-977$，

用16进制表示，

p=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F

## 公钥

公钥是点G与私钥相乘以后曲线上的点，由(x,y)坐标组成，x,y各32字节。非压缩公钥表示方式为`前缀04+x+y`（65字节）。

公钥（不带前缀，64字节）进行keccak256哈希计算之后，得到32字节数据，取后20字节，用16进制表示，就是以太坊地址。

由于根据x坐标和secp256k1椭圆曲线方程能够计算出y坐标值，所以压缩公钥可以用前缀+x的格式表示，前缀表示y的奇偶性，y为偶数时前缀为`02`，y为奇数时前缀为`03`，这样，就得到一个33字节的压缩公钥。

以太坊的签名信息除了R、S外，还额外添加了一个V值（1个字节），签名为`{R,S,V}`，从而组合为一个65字节长度的签名信息。V用来确定公钥点，根据R,S可以recovery两个公钥（即曲线上两个点）,指定V即可确定唯一的真实公钥。