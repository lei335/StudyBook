# KZG BLS PDPv2 椭圆曲线密码学 数据持有证明

## 基本概念

[群的基本概念](https://zhuanlan.zhihu.com/p/281381817)

半群，半群的幂和指数律，幺半群，子半群；群，交换群，群的阶，子群。

[循环群](https://zhuanlan.zhihu.com/p/289408905)

循环子群，生成元，元素的阶；循环群，循环群的生成元。

[群同态](https://zhuanlan.zhihu.com/p/462190430)

群同态和群同构

[椭圆曲线密码学]([椭圆曲线密码学](https://switch-router.gitee.io/blog/ecc/))

公钥加密，椭圆曲线，运算规则，生成元，私钥与公钥，数字签名.

&nbsp;

## G1 G2域

### G1域是什么

椭圆曲线密码学中，有两个重要的椭圆曲线群，分别记作G1和G2。这两个群都是定义在特定的椭圆曲线上的，它们的元素是曲线上的点。

G1域这个群的运算是椭圆曲线上的点加法。G1域中的元素都是椭圆曲线上的点，通常用P表示。点P可以表示为P=(x,y)，其中x,y是实数域上的坐标值，满足椭圆曲线的方程。

在椭圆曲线密码学中，G1域通常用于定义公钥、私钥和签名操作。公钥是椭圆曲线上的点，私钥是一个随机数，而签名操作涉及椭圆曲线上的点的加法和标量乘法等运算。

### G1域的方程

G1域的椭圆曲线方程通常表示为**y^2 = x^3 + ax + b**，其中a,b是常数，这个方程定义了椭圆曲线上的点集合，也就是G1域。

这个方程是一种简化形式，实际上在密码学中会使用一个特定的素数p和有限域上的元素来定义椭圆曲线，这种曲线在密码学中被称为“素数域上的椭圆曲线”。在这个素数域上，曲线方程为**y^2 = x^3 +ax +b mod p**，在实际应用中，选择合适的a、b和p是很重要的，这涉及到椭圆曲线的安全性和效率。

### G1域有哪些常用椭圆曲线

目前常用的G1域椭圆曲线有：

1. secp256k1：   secp256k1是比特币、以太坊和其他一些区块链使用的椭圆曲线。曲线方程是 **y^2 = x^3 +7**，定义在素数域上，使用了一个特定的素数**p=2^256 - 2^32 -977**。

2. secp256r1（也称为NIST P-256）：    是NIST（美国国家标准技术研究院）推荐的一条椭圆曲线，广泛用于加密领域。曲线方程为**y^2 = x^3 - 3x + b**，其中b是一个特定的常数（很大，很长，这里不写），素数**p=2^256 - 2^224 + 2^192 + 2^96 - 1**.

3. secp384r1：是NIST推荐的另一条曲线，提供比secp256r1更高的安全级别。

### G2域是什么

G2域是定义在另一条椭圆曲线上的加法群，G2域用于实现更高级别的安全机制，比如零知识证明。G1域和G2域都是定义在特定椭圆曲线上的，且它们的元素都是曲线上的点。

G1和G2通常会结合使用，形成双线性配对，它们通常都是有限阶的（元素个数有限）。

## BLS

参考：[BLS签名实现阈值签名的流程 | 登链社区 | 区块链技术社区](https://learnblockchain.cn/2019/08/29/bls)

BLS签名算法是一种可以实现签名聚合和密钥聚合的算法，它可以把一笔交易中的所有签名和公钥合并成单个签名和公钥，且合并过程不可见，就是无法追溯这个签名或公钥是否通过合并而来。

### 基本原理

我们知道，ECDSA签名算法无法做签名聚合或者公钥聚合，因此只能挨个对签名进行验证。

Schnorr签名算法就好多了，它可以把一笔交易中的所有签名和公钥合并成单个签名和公钥，且合并过程不可见，另外，可以一次性对合并后的签名做验证，加快了区块验证的速度。该算法不足之处：多重签名需要签名者之间的多次通信，这对冷钱包来说过于麻烦；聚合签名算法依赖随机数生成器，而不像ECDSA那样可以使用指定的随机点（R）；m-n多重签名机制比较取巧，需要构建公钥的默克尔树，当m和n较大时，树会占用较大空间；无法把一个区块中的所有签名聚合成一个签名。

BLS签名算法可以解决以上问题。它不需要随机数生成器，可以将区块中的所有签名聚合成一个，容易实现m-n多重签名，也可以避免签名者之间的多余通信。此外，BLS签名的长度更短（签名为椭圆曲线上的一个点），是Schnoor或ECDSA的二分之一。

#### 曲线哈希

也叫做哈希成曲线上的点。

在BLS算法中，它略微修改了哈希算法，结果对应到椭圆曲线上的一个点。比如说，对消息求哈希时，为了确保能在曲线上找到对应的点，可以在消息体后附加一个数，若（寻找对应点）失败则累加该数并重新计算。即如果hash(m|0)没有找到对应点，则持续尝试hash(m|1)，hash(m|2)等，直到找到为止，当找到对应点后，在2个中选择y坐标较小的那个作为结果即可。

#### 曲线配对

我们还需要一个特殊的函数，能够把一条（或2条不同的）曲线上的两个点P和Q映射为一个数：e(P, Q) -> n

此函数还有一个特性，即对于未知数x和两个点P、Q，无论哪个点乘以x，结果相同，即e(x * P, Q) = e(P, x *  Q)

此外，这些仍然成立：e(a * P, b * Q) = e(P, ab * Q) = e(ab * P, Q) = e(P, Q)^(ab)

暂时不讨论这些如何实现，先假设这种函数存在。

注意：配对函数中不能使用任何椭圆曲线，我们必须使用非常特殊的曲线（通常出自易于配对的曲线簇），才能保证函数的效率和安全。

### BLS签名方案

BLS签名方案是基于双线性配对运算的签名算法，它涉及两个椭圆曲线群G1和G2，并使用双线性配对将G1中的元素映射到G2中的元素。

用pk代表私钥（是一个G1域中的元素），Q = pk * P代表公钥（其中P是G1域中的基点，是椭圆曲线上的一个预先定义的固定点，一般基点都是固定的，被写入密码学标准和协议中；此外，公钥Q是一个G2域中的元素）。

m代表要签名的消息。为了计算签名，先对消息求曲线哈希H(m)，再将获取的结果（曲线坐标点）乘以私钥即可：S = pk * H(m)，其中*表示G1域中的标量乘法，签名S是一个G1域中的标量（scalar）值。大功告成，不需要随机数，不需要额外的步骤，S就是签名结果，签名结果是一个曲线上的点，用压缩的序列化格式保存，只占33个字节。

验证：我们可以使用公钥P来验证签名，即**e(Q, H(m)) = e(P, S)**，其中e是G1域和G2域之间的双线性配对运算。为什么呢？

因为配对函数的特性使得如下等式成立：e(Q, H(m)) = e(pk*P, H(m)) = e(P, pk * H(m)) = e(P, S).

我们只需要验证公钥和消息的哈希值（曲线上的两个点）与曲线生成点和签名（曲线上的另外两个点）是否映射到同一个数，若是则说明这是一个有效的BLS签名。

### 签名聚合

现在让我们把签名聚合在一起，假设一个区块中有1000笔交易，每笔交易都有Si（签名）、Qi（公钥）和mi（消息）组成（i表示序号）。毕竟能合并保存，就没必要分开保存，毕竟我们只关心区块中的所有的签名（而不是每一个）是否正确。为了获得聚合签名，我们只需要将区块中的所有签名加起来：**S = S1 + S2 + ... + S1000**

为验证该区块是否正确，需要保证以下等式成立（需要使用到所有参与者的公钥）：

**e(G, S) = e(Q1, H(m1)) * e(Q2, H(m2)) * ... * e(Q1000, H(m1000))**

如果签名都有效，那么该等式的确成立：

e(P, S) = e(P, S1 + S2 + ... + S1000) = e(P, S1) x e(P, S2) * ... * e(P, S1000)) = e(P, pk1 x H(m1)) * ... * e(P, pk1000 x H(m1000)) = e(pk1 x G, H(m1)) * ... * e(pk1000 x P, H(m1000)) = e(Q1, H(m1)) x e(Q2, H(m2)) * ... * e(Q1000, H(m1000))

好处是，区块中的签名只占33字节了。

BLS签名具有可加性的特性，也就是说，对两个BLS签名进行聚合，其结果等于两个原始签名对应的消息的哈希值的和再进行签名的结果。因此，当需要对多个消息进行签名时，可以分别对每个消息进行哈希，然后将哈希值相加，再对相加后的哈希值进行一次签名，即可得到这些消息的聚合签名。

### 公钥聚合和n-n多重签名

使用多重签名的地址时，会对同一笔交易用不同的私钥进行签名，这种情况，可以将所有公钥和签名聚合成单个公钥和签名。一种简单的聚合方法，是将所有的签名和公钥加起来，如此，签名聚合结果为S = S1 + S2 + S3，公钥聚合结果为Q = Q1 + Q2 + Q3，依然可以验证e(P, S) = e(Q, H(m))。

需要杜绝伪造公钥攻击，一种方法是要求每个签名参与者证明它拥有公钥对应的私钥（用私钥给公钥签名），另一种是加入非线性系数，使得攻击无法实施，即不是简单的将多个密钥和签名相加，而是将它们分别乘以某个系数后再相加：S = a1 x S1 + a2 x S2 + a3 x S3

Q = a1 x Q1 + a2 x Q2 + a3 x Q3

其中，ai = hash(Qi, {Q1, Q2, Q3})，比如，ai = hash(Qi||Q1||Q2||Q3)

### m-n多重签名

bls的m-n多重签名是一种利用 BLS 签名的性质实现多个参与者对同一消息进行签名，而只需要 n 个参与者中的任意 m 个人的签名即可生成有效的多重签名。这个方案允许在一个多方协作环境中，由 n 个人中的任意 m 个人对消息进行签名，从而生成一个有效的多重签名。

具体来说，假设有 n 个参与者，并且每个参与者都有一个 BLS 密钥对，其中包含私钥和公钥。要实现 m-n 多重签名，其中 m 是要求的最小签名个数，n 是参与者的总数。

以下是 BLS m-n 多重签名方案的主要步骤：

1. 密钥生成：每个参与者生成自己的 BLS 密钥对，其中私钥用于签名，公钥用于验证签名。

2. 签名：对要签名的消息进行哈希处理，然后每个参与者使用自己的私钥对哈希值进行签名。

3. 聚合签名：任意 m 个参与者中的签名可以通过简单的数学运算（加法）进行聚合，从而生成一个聚合签名。

4. 验证：使用聚合签名和消息的哈希值，以及参与者的公钥进行验证。验证条件是使用 BLS 的验证算法，验证聚合签名的有效性。

由于 BLS 签名具有可加性的特性，即可以将多个签名聚合成一个签名，并且聚合后的签名仍然有效，因此 BLS 签名非常适合用于实现多重签名方案。通过 BLS 多重签名方案，只需要获得任意 m 个参与者的签名，即可生成有效的多重签名，这在实际应用中非常有用，特别是在需要多个参与者共同签署合同、交易或其他重要操作时。

### BN256椭圆曲线族

BN256，也称为 Barreto-Naehrig 256 位椭圆曲线，是一种椭圆曲线密码学中的椭圆曲线族。它是由 Barreto 和 Naehrig 在2005年提出的，是一种特定的椭圆曲线构造，用于实现配对运算和其他高级密码学算法。

BN256 曲线属于优秀的双线性配对曲线（Bilinear Pairing Curve），它具有高效的配对运算和安全性，因此在一些密码学方案中得到广泛应用。BN256 曲线的设计目标之一是提供高效的配对运算，同时保持足够的安全性。它的安全性基于椭圆曲线离散对数难题和相关的数论假设。

BN256 曲线的具体参数如下：

- 素数 p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
- 曲线方程：y^2 = x^3 + 3
- 基点 G 的横坐标 x = 1（椭圆曲线上的基点也就是椭圆曲线上的一个生成元，即通过对生成元进行重复的点加法运算，可以得到该椭圆曲线上的所有点）
- 有限域的阶（椭圆曲线点的数量）n = 21888242871839275222246405745257275088548364400416034343698204186575808495617

BN256 曲线的性质使得它适用于各种高级密码学算法，特别是在零知识证明、可验证延迟函数（VDF）、身份基加密等方面具有重要的应用。BN256 曲线在区块链和分布式系统中也得到了广泛的应用，特别是在以太坊区块链的密码学机制中。由于其高效性和强大的功能，BN256 曲线成为了许多现代密码学研究和应用中的重要工具。

### BN256和BLS的关系

BN256 和 BLS（Boneh-Lynn-Shacham）是两个不同的概念，分别指代了不同的密码学内容。

1. BN256（Barreto-Naehrig 256）是一种特定的椭圆曲线，用于实现配对运算和其他高级密码学算法。BN256 是一条优秀的双线性配对曲线，具有高效的配对运算和安全性。它由 Barreto 和 Naehrig 在2005年提出，属于椭圆曲线密码学中的一种曲线族。BN256 曲线的参数和性质在前面的回答中已经提及。

2. BLS 是一种签名方案，全称为 Boneh-Lynn-Shacham 签名方案。BLS 签名方案是基于椭圆曲线上的双线性配对运算的签名算法。它由 Dan Boneh、Ben Lynn 和 Hovav Shacham 在2001年提出，被广泛应用于分布式系统和区块链中。

尽管 BN256 和 BLS 都涉及到椭圆曲线上的双线性配对运算，但它们是两个不同的概念。BN256 是椭圆曲线的一种选择，用于实现配对运算和高级密码学算法，而 BLS 是一种签名方案，利用椭圆曲线的性质实现签名操作。在实际应用中，可以将 BLS 签名方案应用于 BN256 曲线上，从而实现高效且安全的签名功能。这样的组合在一些现代密码学和区块链应用中得到了广泛的应用。

### BLS12_381曲线

BLS12-381 是一种特定的椭圆曲线，属于 BLS（Boneh-Lynn-Shacham）家族的椭圆曲线之一。它在密码学和区块链领域得到广泛应用，用于实现数字签名、零知识证明、身份基加密等功能。

BLS12-381 曲线是在有限域上的椭圆曲线，其具体参数如下：

- 定义域：有限域 Fp，其中 p 是一个大素数。
- 素数 p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
- 曲线方程：y^2 = x^3 + 4
- 基点 G 的横坐标 x = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905ab5c4b9a98c7f0c70ef36ece7a6ed1f8f9977123e2a6f25de（椭圆曲线上的基点也就是椭圆曲线上的一个生成元，即通过对生成元进行重复的点加法运算，可以得到该椭圆曲线上的所有点）
- 有限域的阶（椭圆曲线点的数量）n = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaac

BLS12-381 曲线具有高度安全性，并且在椭圆曲线密码学中拥有许多优秀的性质。由于其高效性和强大的功能，BLS12-381 曲线被广泛应用于区块链、分布式系统和加密货币等领域。例如，以太坊 2.0 采用了 BLS12-381 曲线作为其加密方案的基础，用于实现有效的数字签名和验证功能。总的来说，BLS12-381 曲线是现代密码学中一个重要的工具，为许多应用场景提供了安全和高效的密码学支持。

### BLS12_377曲线

G1生成元$g_1$

### 坐标表示

实际应用中，有基本仿射（Affine）坐标形式(X, Y)，也可以将点表示为雅可比（Jacobian）坐标形式(X, Y, Z)，Jacobian坐标形式最大的好处是不需要求逆，方便计算点乘运算（kP），因此一般在计算时，会将点转换为Jacobian坐标形式，必要时再转化为放射坐标形式。

https://zhuanlan.zhihu.com/p/87490028

## KZG多项式承诺

KZG多项式承诺基于多项式的点值形式，即将多项式在一组特定点上的取值作为承诺。该方案通常被称为卡特多项式承诺方案。

在了解KZG多项式承诺之前，我们先了解一下默克尔树。

### 默克尔树

首先默克尔树是什么想必应该已经比较了解了。这里只利用默克尔树来进行举例说明。

默克尔树既是密码学家所说的矢量承诺：运用一个深度为d的默克尔树，你可以计算一个矢量的承诺（矢量为一个固定长度的列表a<sub>0</sub>，...，a<sub>2<sup>d</sup>-1</sub>）。运用默克尔证明，可以用d个哈希值来提供证明元素a<sub>i</sub>存在于这个矢量的位置i。

在多项式$p(X) = \sum_{i=0}^np_iX^i$中，其中$pi$是该多项式的系数，要想证明对于一个值$z$，$p(z) = y$。为达到证明的目的，证明者可以向验证者发送所有的$p_i$，然后验证者计算$p(z)$是否等于$y$。

这是一个极度简化的多项式承诺。

默克尔树多项式承诺的性质：

1. 承诺的大小是一个单一哈希（默克尔树根）。一个足够安全的加密散列一般需要256位，即32字节。

2. 为了证明一个取值，证明者需要发送所有的pi，所以证明的大小和多项式次数是线性相关的。同时，验证者需要做同等的线性量级的计算（他们需要计算多项式在z点的取值，即计算$p(z) = \sum_{i=0}^np_iz^i$）。

3. 该方案不隐藏多项式的任何部分 - 证明者一个系数接一个系数地发送完整的多项式。

### 卡特方案

而卡特方案具有这些性质：

1. 承诺大小是一个支持配对的椭圆曲线群元素。比如说对于BLS12_381曲线，大小应是48字节。

2. 证明大小独立于多项式大小，永远是一个群元素。验证，同样独立于多项式大小，无论多项式次数为多少都只要两次群乘法和两次配对。

3. 大多数时候该方案隐藏多项式 - 事实上，无限多的多项式将会拥有完全一样的卡特承诺。但是这并不是完美隐藏：如果你能猜多项式（比如说该多项式过于简单，或者它存在于一个很小的多项式集合中），你就可以找到这个被承诺的多项式。

### 什么是KZG多项式承诺

在一个多项式方案中，证明者计算一个多项式的承诺，并可以在多项式的任意一点进行打开，该承诺方案能证明多项式在特定位置的值与指定的值一致。

#### 承诺是什么

在多项式承诺中，证明者计算一个多项式的承诺是指对一个多项式进行一系列特定的操作，以生成对该多项式的承诺。这个承诺值可以用来证明多项式的正确性和完整性，而不需要透露多项式的具体系数。

具体而言，对于一个 n 次多项式 P(x) = a0 + a1*x + a2*x^2 + ... + an*x^n，其中 a0, a1, a2, ..., an 是多项式的系数，证明者可以执行以下操作来计算多项式的承诺：

1. 选择一个合适的椭圆曲线上的基点 G，作为多项式承诺的生成元。

2. 将多项式的系数 a0, a1, a2, ..., an 映射到椭圆曲线上的点，得到点集 {a0*G, a1*G, a2*G, ..., an*G}。这个过程可以使用椭圆曲线上的标量乘法来实现，即将系数与基点相乘。

3. 将得到的点集中的所有点相加，得到多项式的承诺值 Commitment = a0*G + a1*G + a2*G + ... + an*G。

证明者计算的多项式承诺值 Commitment 可以被用作多项式的承诺，并提供给验证者。验证者可以使用椭圆曲线上的双线性配对运算来验证多项式的承诺的正确性。在验证过程中，验证者会根据承诺值 Commitment 和其他相关信息，确保多项式的正确性，并验证该承诺是否对应于给定的多项式。

多项式承诺在区块链、零知识证明等领域有广泛应用，用于验证数据的完整性和正确性，同时保护多项式的隐私和安全性。

#### KZG数学原理

多项式可以表达为：

$$
f(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} + a_nx^n
$$

这是一个椭圆曲线群（注意： $[q+1]G_1 = 0$，有限域）：

$$
G_1 = [0,{\,} G_1,{\,} G_1+G_1=[2]G_1,{\,} [3]G_1,{\,}...,{\,} [q]G_1]
$$

我们知道椭圆曲线群有这样的特性：$[n]G_1 = [n]_1$可以非常快的计算出来，而$[n]X = Y$，给出$X$和$Y$，是非常难找到n的。

但多项式和椭圆曲线群$G_1$相结合，可得：

$$
[f(x)]G_1 = [\sum_{i=0}^na_ix^i]G_1 = \sum_{i=0}^n[a_i]([x^i]G_1) = \sum_{i=0}^n[a_i][x^i]_1
$$

具有可信设置的多项式承诺：

通过多方计算可信设置生成无人知晓的$s$，$s \in\ F_q$（可理解为无人知晓的私钥），$[s^i]G_1 = [S^i]_1, {\,}...$ 这部分是公开的（可理解为公钥）。

> 多方计算可信设置是指在多方计算（简称MPC，是一种密码学技术，允许多个参与者在不泄露各自私密信息的情况下，联合计算出一个结果）协议中，为了确保协议安全性和正确性，需要预先由参与计算的各方合作生成一个可信的设置。可信设置的生成通常包括以下步骤：
> 
> - 参数生成：椭圆曲线参数、随机数、初始状态等，确保随机、不可预测
> 
> - 验证和共享：确保每个参与者拥有相同的参数
> 
> - 可信性验证，确保可信设置没有恶意操纵

计算承诺：

$$
C = [f(s)]_1 = \sum_{i=0}^n[a_i][s^i]1
$$

卡特承诺为C，C是可以公开计算出来的，C是椭圆曲线群上的某一点。

总结：生成承诺和证明涉及椭圆曲线、拉格朗日插值、线性配对技术，计算过程比较复杂。只需要记住生成承诺是根据多项式的系数生成一个椭圆曲线上的点C（Commitment，只有48字节），生成证明是根据多项式的系数和多项式最高次幂n生成一个椭圆曲线上的点P（Proof，只有48字节）。在这个过程中，没有向外暴露多项式的系数。

验证过程：先确认基本参数（有限域F、基点G、安全参数n）是否一致；计算点集$\{G\_0,G\_1,G\_2,...,G\_n\}$，其中$Gi = i*G$；验证Proof（和生成同样计算）；验证承诺值Commitment；验证多项式的值（这个多项式是生成proof时用到的）。如果都一致都通过，则说明承诺是有效的。注意：验证者不需要知道完整的多项式。

#### 应用bls12-381曲线和kzg多项式承诺技术

通过多方计算生成一个私密参数s，公开 `ψ=s*g_2`，也就是验证公钥vk；并且公开`s_i = s^i*g_1`。其中，`g_2`是bls12_381曲线的G2生成元，`g_1`是bls12_381曲线的G1生成元。

对于要被证明的数据，可以将其看作是向量P: {p0, p1, ... , `p_{n-1}` }，其中pi ∈ Fr，大小不超过32字节，可以将数据分割为32字节的atoms，然后将每一个atom转换为Fr元素。

然后将向量P构建成一个多项式 `P(x) = \sum_{i=0}^{n-1}p_ix^i` ，之后得到该文件的承诺C，`C = P(s)g_1 = \sum_{i=0}^{n-1}p_i s_i` ，C是一个G1点。

**证明：**

证明者需要提供数据P的持有证明proof。

验证者给定一个随机数z（bytes32），数据拥有者也就是证明者可以计算：`y = P(z)`，并且取多项式`Q(x) = \frac{P(x)-y}{x-z}`，其中，`Q(x) = \frac{P(x)-y}{x-z} = \sum_{i=0}^{n-2}q_ix^i`，其中， `q_{n-2} = p_{n-1}` ，`q_i = p_{i+1} + q_{i+1} * y` 。

从而计算：`π = Q(s)g_1 = \sum_{i=0}^{n-2}q_is_i`

证明proof即为 （`y`，`π`）。

**验证：**

验证者在不知道数据的情况下，即在不知道向量P的情况下，根据公开参数`ψ` 、z、y、 `π` 、 `C`，验证证明者确实知道数据。验证者根据bls12_381的线性配对性质，验证`e(π, ψ-z*g_2) = e(C - y*g_1, g_2)`即可，如果验证通过，则可以确定证明者知道数据P，否则证明者不知道数据P。

**批量证明：**

在同一个随机数z的情况下，证明者提供批量证明。批量生成各个文件的承诺`C_j`以及证明（`y_j`， `π_j` ）。设`ϕ = y*g_1`，则聚合承诺Cn、聚合证明（`ϕ`，`π`）依次为：

`C = \sum_{j=0}^{m-1}C_j`

`ϕ = \sum_{j=0}^{m-1}ϕ_j`

`π=\sum_{i=0}^{m-1}π_j`

验证者依然是验证：`e(π, ψ-z*g_2) = e(C - ϕ, g_2)`。

## 以太坊BLS12_381

https://github.com/ethereum/go-ethereum/blob/master/crypto/bls12381/g1.go#L28

**G1Point**由三个Fe元素构成，即 `type PointG1 [3]fe`，其中，`type fe [6]uint64`，G1点由（x, y）组成，x,y均为48bytes，PointG1前两个元素为x,y，第三个元素不重要，暂时不用理会，是`new(fe).one()`；一般可传入128字节表示G1点，前64字节解码成48字节的x，后64字节解码成48字节的y。

详细可见函数`func (g *G1) FromBytes(in []byte) (*PointG1, error)`、`func (g *G1) ToBytes(p *PointG1) []byte`、`func DecodePoint(in []byte) (*PointG1, error)`

**G2Point**由三个fe2元素组成，即`type PointG2 [3]fe2`，其中，`type fe2 [2]fe`，G2点也是由（x, y）组成，x,y均为96bytes，PointG1前两个元素为x,y，第三个元素不重要，暂时不用理会，是`new(fe2).one()`；一般可传入256字节表示G2点，然后解码得到PointG2。

详细可见函数`func (g *G2) FromBytes(in []byte) (*PointG2, error)`、`func (g *G2) ToBytes(p *PointG2) []byte`、`func DecodePoint(in []byte) (*PointG2, error)`

## MEMO PDPV2

**Sk:**

blsSk Fr    // bytes32

alpha Fr    // bytes32

elemAlpha []Fr    // {1, alpha, alpha^2, ..., alpha^(n-1)}

&nbsp;

**Pk:**

blsPk G2    // g_2 *blsSk，g_2是G2群的生成元

zeta G2    // g_2 * (alpha * blsSk)

phi G1    // g_1 * blsSk，g_1是G1群的生成元

elemAlphas []G1    // {g_1, g_1 * alpha, g_1 * alpha^2, ... , g_1 * alpha^(n-1)} = g_1 * Sk.elemAlpha

&nbsp;

**Vk:**

Pk.blsPk

Pk.zeta

Pk.phi

&nbsp;

**Proof:**

Psi G1

Kappa G1

&nbsp;

**Challenge:**

r bytes32

pubInput Fr    // bytes32

&nbsp;

**SplitDataToAtom:**

将数据（MEMO中是segment的格式）分割成指定大小（byte）的小块，MEMO中是31字节且分割成n块，每一小块转换为一个Fr域元素，bytes32，得到atoms []Fr

&nbsp;

**GenTag:** 

index, segment bytes

先将 segment 划分得到 atoms（调用 SplitDataToAtom）

分两种情况，知道Sk和不知道Sk。

知道Sk：

计算 power = atom[0] + atom[1] * alpha + atom[2] * alpha^2 + ... + atom[n-1] * alpha^(n-1)，Fr

然后计算 uMiDel = GenG1 * power = g_1 * atom[0] + g_1 * atom[1] * alpha + ... + g_1 * atom[n-1] * alpha^(n-1)，（GenG1 = g1，即为G1域的生成元），G1

不知道Sk：

计算 uMiDel = Pk.elemAlphas[0] * atoms[0] + Pk.elemAlphas[1] * atoms[1] + ... + Pk.elemAlphas[n-1] * atoms[n-1]，G1

两种情况计算所得的 uMiDel是一样的。

之后，将 segment对应的index转化（blake3.Sum256）为一个Fr元素HWi，32bytes；

HWiG1 = g_1 * HWi    // G1

tag = uMiDel + HWiG1    // G1

如果需要加密签名，则tag= tag* blsSk.

得到与segment和index相对应的tag.

&nbsp;

**VerifyTag:**

index, segment bytes; tag G1

按照上面 GenTag的方法根据segment和index计算 ProdHWimu = g_1 * HWi + uMiDel，G1

调用 bls.PairingsVerify(tag, g_2, ProdHWimu, blsPk) 函数，判断 e(tag^(-1), g_2) * e(ProdHWimu, blsPk) = fe12.one()，fe12.one() 等于 r mod p = r1，其中r为子群G1的阶，即点的总个数，p为有限域的参数，即椭圆曲线上的点坐标都要mod p，是381位的。

&nbsp;

**GenProof:**

Pk; chal(r, pubInput) Challenge; segment bytes; tag G1

调用 SplitDataToAtom 将segment分割成atoms，atoms数量为n

计算 pk_r = atom[0] + atom[1] * r + atom[2] * r^2 + ... + atom[n-1] * r^(n-1)

感觉像是把 atoms当成多项式 poly(x)的参数，构造一个多项式poly(x)，计算poly(r)的值。

计算 quotient [n-1]Fr = {atoms[n-1] * r^(n-2) + atoms[n-2] * r^(n-3) + ... + atoms[1], atoms[n-1] * r^2 + atoms[n-2] * r + atoms[n-3], atoms[n-1] * r + atoms[n-2], atoms[n-1]}

即 quotient_(n-1) = atoms_n，quotient_j = atoms_(j+1) + quotient_(j+1) * r；atoms_n表示atoms的第n个数字，用下标表示则为atoms[n-1]

计算 psi = quotient[0] * elemAlphas[0] + quotient[1] * elemAlphas[1] + ... + quotient[n-2] * elemAlphas[n-2]，G1

计算 kappa = tag - (phi * pk_r)

返回计算得到的psi和kappa即为proof

可以见得，GenProof时不需要用到pubInput，也就是不需要index相关

&nbsp;

**VerifyProof:**

Vk; chal(r, pubInput) Challenge; proof(psi, kappa)

计算 G1temp1 = kappa - (phi * pubInput)

计算 G2temp1 = Vk.zeta - blsPk * r

调用 PairingsVerify(G1temp1, g_2, psi, G2temp1) 函数，即判断是否符合配对性质，也就是判断 e(G1temp1^(-1), g_2) * e(psi, G2temp1) = r1

可以见得，VerifyProof时才需要用到pubInput，也就是index相关

&nbsp;

**ProofAggregator:**

Pk

r bytes32    // chal.r

sums []Fr    // []bytes32

delta G1

tempG1 G1

tempFr Fr

HWi Fr

&nbsp;

**AggregateProofs:**

分为两步，第一步Add，第二步Result

对每一个要产生proof的文件执行Add操作；当所有文件都Add结束后，执行一次Result操作，就得到聚合proof。

Add(index, segment bytes, tag G1):

调用 SplitDataToAtom 将segment分割成atoms，atoms数量为n

先计算sums[j] = sums[j] + atoms[j]

相当于把所有文件的对应atom[i]加到一起得到sums[i]

计算delta = delta + tag

相当于把所有文件的tag加到一起得到delta

计算HWi = HWi + index

相当于把所有文件的index加到一起得到HWi

Result():

sums就相当于GenProof中的atoms，delta相当于GenProof中的tag，HWi相当于GenProof中的pubInput

之后就和GenProof一样的操作得到psi和kappa

注意：计算得到psi和kappa后，并不着急返回，而是会先执行VerifyProof的操作验证一下。

### 总结

上面的MEMO PDPV2因为考虑了很多其他情况，所以做的比较复杂，除去复杂的事情，其实应用的就是bls12_381曲线以及kzg多项式承诺技术。我们总结如下：

alpha相当于私密的s（该s通过多方计算MPC，因此没有人知道），公开  $s_i  = s^i * g_1$ ，也就是elemAlphas，公开 $ψ  = s * g_2$，也就是简化版的zeta。

对于要被证明的数据，可以将其看作是向量P：{p0, p1, ... ,  $p_{n-1}$ }，其中pi ∈ Fr，大小不超过32字节，可以将数据分割为32字节的atoms，然后将每一个atom转换为Fr元素。

然后将向量P构建成一个多项式  $P(x) = \sum_{i=0}^{n-1}p_ix^i$ ，

之后得到**承诺**C， $C = P(s)g_1 = \sum_{i=0}^{n-1}p_i  s_i$ ，也就是 $\sum_{i=0}^{n-1}p_i * elemAlphas[i]$ ，C是一个G1点。

* 证明

证明者需要提供**证明**proof。验证者给定一个随机数z  bytes32，也就是上面PDPV2中的r，数据拥有者也就是证明者可以计算： $y = P(z)$ ，

并且取多项式  $Q(x) = \frac{P(x)-y}{x-z}$  ，其中，  $Q(x) = \frac{P(x)-y}{x-z} = \sum_{i=0}^{n-2}q_ix^i$  ，

其中，  $q_{n-2} = p_{n-1}$ ，$q_i = p_{i+1} + q_{i+1} * y$  。这是根据[单元多项式的除法的综合除法中当g(x)=x-a时的原理](chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fwww.knewstep.com%2Fwp-content%2Fuploads%2F2020%2F01%2FSU_Maths_Day-3_%25E5%25A4%259A%25E9%25A0%2585%25E5%25BC%258F_Teacher-Lam_Worksheet.pdf)可得，当然自己也可以根据$a^n - b^n = (a-b)*a^{n-1} + b*(a^{n-1} - b^{n-1})$推导出来。

从而计算：$π = Q(s)g_1 = \sum_{i=0}^{n-2}q_is_i$ 

**证明**即为（$y$，$π$）。

* 验证

验证者在不知道数据的情况下，即在不知道向量P的情况下，根据公开参数  $ψ$ 、z、y、 $π$ 、 $C$ ，验证证明者确实知道数据。验证者根据线性配对，**验证** $e(π, ψ-z*g_2) = e(C - y*g_1, g_2)$ 即可，如果验证通过，则可以确定证明者知道数据P，否则证明者不知道数据P。设 $ϕ = y*g_1$ 

因为：

$e(π,ψ-z*g_2) = e(\frac{P(s)-y}{s-z}*g_1, (s-z)*g_2) = e(g_1, g_2)^{P(s)-y}$

$e(C-y*g_1, g_2) = e((P(s)-y)*g_1, g_2) = e(g_1, g_2)^{P(s)-y}$

也就是说 $e(C-y*g_1, g_2).e(-π,ψ-z*g_2)=1$

* 批量证明

在同一个随机数z的情况下，证明者提供批量证明。批量生成承诺 $C_j$ 以及证明（$y_j$， $π_j$ ）。

验证者随机选择t，一个32字节的随机数，证明者计算

$C = \sum_{j=0}^{m-1}t^jC_j$

$ϕ = \sum_{j=0}^{m-1}t^jϕ_j$

$π=\sum_{i=0}^{m-1}t^jπ_j$

验证者仍然是验证： $e(π, ψ-z*g_2) = e(C - ϕ, g_2)$
